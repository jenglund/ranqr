<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RanQR - Rank Collections by Pairwise Comparisons</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .section-title {
            font-size: 1.5em;
            margin-bottom: 15px;
            color: #667eea;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
        }

        input[type="text"], textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        textarea {
            min-height: 150px;
            resize: vertical;
            font-family: inherit;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 1em;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: #6c757d;
        }

        button.danger {
            background: #dc3545;
        }

        .matchup-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
            justify-content: center;
            min-height: 200px;
        }
        
        .matchup-items-row {
            display: flex;
            gap: 20px;
            align-items: center;
            justify-content: center;
            width: 100%;
        }
        
        @media (max-width: 800px) {
            .matchup-items-row {
                flex-direction: column;
            }
            .matchup-items-row .matchup-item {
                width: 100%;
            }
        }

        .matchup-item {
            flex: 1;
            min-width: 250px;
            padding: 30px;
            border: 3px solid #ddd;
            border-radius: 12px;
            text-align: center;
            background: #f8f9fa;
            transition: border-color 0.3s ease;
        }

        .matchup-vs {
            font-size: 1.5em;
            font-weight: bold;
            color: #667eea;
        }

        .matchup-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
            width: 100%;
        }
        
        @media (max-width: 600px) {
            .matchup-buttons {
                flex-direction: column;
                align-items: stretch;
            }
            
            .matchup-buttons button {
                width: 100%;
            }
        }

        .matchup-buttons button {
            min-width: 120px;
        }

        .vote-select-btn {
            transition: all 0.2s;
        }

        .vote-select-btn.selected {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4);
        }

        .vote-select-btn.selected.secondary {
            background: #6c757d;
            box-shadow: 0 5px 15px rgba(108, 117, 125, 0.4);
        }

        .collections-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
        }

        .collection-card {
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            background: #f8f9fa;
        }

        .collection-card h3 {
            margin-bottom: 10px;
            color: #667eea;
        }

        .collection-card .meta {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        .collection-card .actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .collection-card .actions button {
            flex: 1;
            padding: 8px;
            font-size: 0.9em;
        }

        .rankings-list {
            list-style: none;
        }

        .rankings-list li {
            padding: 12px;
            margin-bottom: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid #667eea;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .rankings-list li:nth-child(1) {
            border-left-color: #ffd700;
            background: linear-gradient(90deg, #fff9e6 0%, #fff 100%);
        }

        .rankings-list li:nth-child(2) {
            border-left-color: #c0c0c0;
            background: linear-gradient(90deg, #f5f5f5 0%, #fff 100%);
        }

        .rankings-list li:nth-child(3) {
            border-left-color: #cd7f32;
            background: linear-gradient(90deg, #f5e6d3 0%, #fff 100%);
        }

        .rank-number {
            font-weight: bold;
            color: #667eea;
            margin-right: 10px;
            min-width: 30px;
        }

        .item-name {
            flex: 1;
        }

        .item-points {
            font-weight: bold;
            color: #555;
        }

        .item-points.positive {
            color: #28a745;
        }

        .item-points.negative {
            color: #dc3545;
        }

        .hidden {
            display: none;
        }

        .view-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .view-controls button {
            flex: 1;
        }

        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .stat-card {
            flex: 1;
            min-width: 150px;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
            text-align: center;
        }

        .stat-card .value {
            font-size: 2em;
            font-weight: bold;
        }

        .stat-card .label {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .matchup-item {
            display: flex;
            flex-direction: column;
        }

        .matchup-item-content {
            flex: 1;
        }

        .video-container {
            width: 100%;
            max-width: 560px;
            margin: 15px auto;
            position: relative;
            padding-bottom: 56.25%; /* 16:9 aspect ratio */
            height: 0;
            overflow: hidden;
        }

        .video-container iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 8px;
        }

        .item-actions {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }

        .item-actions button {
            padding: 6px 12px;
            font-size: 0.85em;
        }

        .edit-form {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }

        .edit-form input {
            flex: 1;
            padding: 8px;
            font-size: 0.9em;
        }

        .add-items-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #ddd;
        }

        .media-link-display {
            font-size: 0.85em;
            color: #666;
            margin-top: 5px;
        }

        .media-link-display a {
            color: #667eea;
            text-decoration: none;
        }

        .media-link-display a:hover {
            text-decoration: underline;
        }

        .vote-item-card {
            padding: 12px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid #667eea;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .vote-item-card:hover {
            background: #e9ecef;
            transform: translateX(5px);
        }

        .vote-item-card.win {
            border-left-color: #28a745;
        }

        .vote-item-card.loss {
            border-left-color: #dc3545;
        }

        .vote-item-card.tie {
            border-left-color: #6c757d;
        }

        .vote-item-name {
            flex: 1;
            font-weight: 600;
        }

        .vote-item-action {
            color: #667eea;
            font-size: 0.9em;
            padding: 4px 8px;
            border-radius: 4px;
            background: white;
            cursor: pointer;
        }

        .vote-item-action:hover {
            background: #667eea;
            color: white;
        }

        /* Histogram Styles */
        .histogram {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            gap: 8px;
            padding: 20px;
            min-height: 200px;
            border-bottom: 2px solid #ddd;
            position: relative;
        }

        .histogram-bar {
            flex: 1;
            min-width: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 4px 4px 0 0;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
        }

        .histogram-bar:hover {
            opacity: 0.8;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.4);
        }

        .histogram-bar-label {
            position: absolute;
            bottom: -25px;
            font-size: 0.85em;
            color: #666;
            font-weight: 600;
            white-space: nowrap;
        }

        .histogram-bar-value {
            position: absolute;
            top: -25px;
            font-size: 0.9em;
            color: #667eea;
            font-weight: bold;
            background: white;
            padding: 2px 6px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .histogram-bar:hover .histogram-bar-value {
            opacity: 1;
        }

        .histogram-axis {
            display: flex;
            justify-content: space-between;
            padding: 10px 20px;
            color: #666;
            font-size: 0.9em;
        }

        /* Sub-score Histogram Popup */
        .sub-score-popup {
            position: fixed;
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            padding: 20px;
            z-index: 2000;
            min-width: 400px;
            max-width: 600px;
        }

        .sub-score-popup h4 {
            margin: 0 0 15px 0;
            color: #667eea;
            font-size: 1.2em;
        }

        .sub-score-popup .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sub-score-popup .close-btn:hover {
            color: #dc3545;
        }

        .sub-histogram {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            gap: 6px;
            padding: 15px;
            min-height: 150px;
            border-bottom: 2px solid #ddd;
        }

        .sub-histogram-bar {
            flex: 1;
            min-width: 25px;
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            border-radius: 3px 3px 0 0;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
        }

        .sub-histogram-bar-label {
            position: absolute;
            bottom: -20px;
            font-size: 0.8em;
            color: #666;
            font-weight: 600;
        }

        .sub-histogram-bar-value {
            position: absolute;
            top: -20px;
            font-size: 0.85em;
            color: #28a745;
            font-weight: bold;
            background: white;
            padding: 2px 5px;
            border-radius: 3px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ RanQR - Rank Your Collections</h1>

        <div id="collections-view" class="card">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-wrap: wrap; gap: 15px;">
                <h2 class="section-title" style="margin: 0;">Your Collections</h2>
            </div>
            <div id="collections-list" class="collections-list"></div>
            
            <h3 class="section-title" style="margin-top: 30px;">Create New Collection</h3>
            <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                <button onclick="showCreateDialog()">‚ûï Create Collection</button>
                <button onclick="showImportDialog()">üì§ Import Collection</button>
            </div>
            
            <div id="create-collection-form" class="hidden">
                <div class="form-group">
                    <label for="collection-name">Collection Name:</label>
                    <input type="text" id="collection-name" placeholder="Enter collection name">
                </div>
                <div class="form-group">
                    <label for="search-prefix-input">YouTube Search Prefix (optional):</label>
                    <input type="text" id="search-prefix-input" placeholder="e.g., artist name, series name...">
                    <small style="color: #666; font-size: 0.9em;">This will be added to YouTube searches for items in this collection</small>
                </div>
                <div class="form-group">
                    <label for="items-input">Items (one per line):</label>
                    <textarea id="items-input" placeholder="Enter items, one per line..."></textarea>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button onclick="createCollection()">Create Collection</button>
                    <button class="secondary" onclick="hideCreateDialog()">Cancel</button>
                </div>
            </div>
        </div>

        <div id="collection-view" class="hidden">
            <div class="card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 class="section-title" style="margin: 0;" id="collection-title"></h2>
                    <button class="secondary" onclick="showCollections()">‚Üê Back to Collections</button>
                </div>
                
                <div class="view-controls">
                    <button onclick="showMatchup()">Make Comparisons</button>
                    <button onclick="showRankings()">View Rankings</button>
                    <button onclick="showFixedTriangles()">Resolve Triangles</button>
                </div>

                <div id="stats" class="stats hidden"></div>
            </div>

            <div id="matchup-section" class="card hidden">
                <h3 class="section-title">Pairwise Comparison</h3>
                <div id="matchup-container" class="matchup-container">
                    <div class="loading">Loading next matchup...</div>
                </div>
                <div id="matchup-edit-section" class="hidden" style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #ddd;">
                    <h4 style="margin-bottom: 15px; color: #667eea;">Edit Items</h4>
                    <div id="matchup-edit-items" style="display: flex; flex-direction: column; gap: 15px;"></div>
                </div>
            </div>

            <div id="rankings-section" class="card hidden">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3 class="section-title" style="margin: 0;">Current Rankings</h3>
                    <button onclick="editCollectionSearchPrefix()" style="padding: 6px 12px; font-size: 0.9em;">‚öôÔ∏è Edit Search Prefix</button>
                </div>
                
                <div id="collection-search-prefix-display" style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 6px;">
                    <strong>YouTube Search Prefix:</strong> <span id="search-prefix-value">None</span>
                </div>
                
                <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                    <div style="position: relative;">
                        <button onclick="toggleExportMenu()">üì• Export Collection</button>
                        <div id="export-menu" class="hidden" style="position: absolute; top: 100%; left: 0; margin-top: 5px; background: white; border: 2px solid #667eea; border-radius: 6px; box-shadow: 0 5px 15px rgba(0,0,0,0.2); z-index: 100; min-width: 200px;">
                            <button onclick="exportCollectionToFile(event)" style="width: 100%; text-align: left; border: none; border-bottom: 1px solid #ddd; border-radius: 0; padding: 10px 15px; background: white; cursor: pointer;">üíæ Download as File</button>
                            <button onclick="exportCollectionToClipboard(event)" style="width: 100%; text-align: left; border: none; border-radius: 0; padding: 10px 15px; background: white; cursor: pointer;">üìã Copy to Clipboard</button>
                        </div>
                    </div>
                </div>
                
                <div id="histogram-section" style="margin-bottom: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px;">
                    <h4 style="margin-bottom: 15px; color: #667eea;">Score Distribution</h4>
                    <div id="histogram-container" style="min-height: 200px; position: relative;">
                        <div class="loading">Loading histogram...</div>
                    </div>
                </div>

                <div class="add-items-section">
                    <h4 style="margin-bottom: 10px; color: #667eea;">Add New Items</h4>
                    <div class="form-group">
                        <label for="new-items-input">Items (one per line):</label>
                        <textarea id="new-items-input" placeholder="Enter new items, one per line..."></textarea>
                    </div>
                    <button onclick="addItemsToCollection()">Add Items</button>
                </div>

                <ul id="rankings-list" class="rankings-list"></ul>
            </div>

            <div id="fixed-triangles-section" class="card hidden">
                <h3 class="section-title">Resolve Triangles</h3>
                <div id="triangles-container">
                    <div class="loading">Loading triangles...</div>
                </div>
            </div>
        </div>
        
        <!-- Import Dialog - Outside both views so it's always accessible -->
        <div id="import-dialog" class="hidden" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
            <div class="card" style="max-width: 600px; max-height: 80vh; overflow-y: auto;">
                <h3 class="section-title">Import Collection</h3>
                <div class="form-group">
                    <label for="import-json-input">Paste JSON data:</label>
                    <textarea id="import-json-input" style="min-height: 300px; font-family: monospace;" placeholder='{"version":"1.0","collection":{"name":"..."},"items":[...],"comparisons":[...]}'></textarea>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button onclick="importCollection()">Import</button>
                    <button class="secondary" onclick="hideImportDialog()">Cancel</button>
                </div>
            </div>
        </div>
        
        <!-- Voting History Dialog -->
        <div id="votes-dialog" class="hidden" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
            <div class="card" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3 class="section-title" style="margin: 0;" id="votes-item-name"></h3>
                    <button class="secondary" onclick="hideVotesDialog()">‚úï Close</button>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                        <div class="stat-card" style="min-width: 120px;">
                            <div class="value" id="votes-wins-count">0</div>
                            <div class="label">Wins</div>
                        </div>
                        <div class="stat-card" style="min-width: 120px;">
                            <div class="value" id="votes-losses-count">0</div>
                            <div class="label">Losses</div>
                        </div>
                        <div class="stat-card" style="min-width: 120px;">
                            <div class="value" id="votes-ties-count">0</div>
                            <div class="label">Ties</div>
                        </div>
                        <div class="stat-card" style="min-width: 120px;">
                            <div class="value" id="votes-points">0</div>
                            <div class="label">Points</div>
                        </div>
                    </div>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <button class="danger" onclick="resetItemVotes()" id="reset-votes-btn">üîÑ Reset All Votes</button>
                </div>
                
                <div id="votes-wins-section" style="margin-bottom: 20px;">
                    <h4 style="color: #28a745; margin-bottom: 10px;">‚úì Won Against</h4>
                    <div id="votes-wins-list" style="display: flex; flex-direction: column; gap: 8px;"></div>
                </div>
                
                <div id="votes-losses-section" style="margin-bottom: 20px;">
                    <h4 style="color: #dc3545; margin-bottom: 10px;">‚úó Lost Against</h4>
                    <div id="votes-losses-list" style="display: flex; flex-direction: column; gap: 8px;"></div>
                </div>
                
                <div id="votes-ties-section">
                    <h4 style="color: #6c757d; margin-bottom: 10px;">= Tied With</h4>
                    <div id="votes-ties-list" style="display: flex; flex-direction: column; gap: 8px;"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentCollectionId = null;
        let currentCollection = null;

        // Initialize
        window.onload = () => {
            loadCollections();
        };

        async function loadCollections() {
            try {
                const response = await fetch('/api/collections');
                const collections = await response.json();
                
                const listEl = document.getElementById('collections-list');
                listEl.innerHTML = '';
                
                if (collections.length === 0) {
                    listEl.innerHTML = '<p style="text-align: center; color: #666;">No collections yet. Create one above!</p>';
                    return;
                }
                
                collections.forEach(collection => {
                    const card = document.createElement('div');
                    card.className = 'collection-card';
                    card.innerHTML = `
                        <h3>${escapeHtml(collection.name)}</h3>
                        <div class="meta">${collection.item_count} items</div>
                        <div class="actions">
                            <button onclick="openCollection(${collection.id})">Open</button>
                            <button class="danger" onclick="deleteCollection(${collection.id})">Delete</button>
                        </div>
                    `;
                    listEl.appendChild(card);
                });
            } catch (error) {
                console.error('Error loading collections:', error);
                alert('Error loading collections');
            }
        }

        function getYouTubeSearchUrl(searchPrefix, itemName) {
            // Combine search prefix and item name, properly URL-encoded
            const query = searchPrefix ? `${searchPrefix} ${itemName}` : itemName;
            return `https://www.youtube.com/results?search_query=${encodeURIComponent(query)}`;
        }

        async function createCollection() {
            const name = document.getElementById('collection-name').value.trim();
            const searchPrefix = document.getElementById('search-prefix-input').value.trim();
            const items = document.getElementById('items-input').value.trim();
            
            if (!name) {
                alert('Please enter a collection name');
                return;
            }
            
            if (!items) {
                alert('Please enter at least one item');
                return;
            }
            
            try {
                const response = await fetch('/api/collections', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        name,
                        search_prefix: searchPrefix || null,
                        items
                    })
                });
                
                if (response.ok) {
                    hideCreateDialog();
                    loadCollections();
                    const data = await response.json();
                    openCollection(data.id);
                } else {
                    alert('Error creating collection');
                }
            } catch (error) {
                console.error('Error creating collection:', error);
                alert('Error creating collection');
            }
        }

        async function openCollection(id) {
            currentCollectionId = id;
            try {
                const response = await fetch(`/api/collections/${id}`);
                currentCollection = await response.json();
                
                document.getElementById('collections-view').classList.add('hidden');
                document.getElementById('collection-view').classList.remove('hidden');
                document.getElementById('collection-title').textContent = currentCollection.name;
                
                // Update search prefix display
                const prefixDisplay = document.getElementById('search-prefix-value');
                if (prefixDisplay) {
                    prefixDisplay.textContent = currentCollection.search_prefix || 'None';
                }
                
                showRankings();
            } catch (error) {
                console.error('Error opening collection:', error);
                alert('Error opening collection');
            }
        }

        function showCollections() {
            document.getElementById('collections-view').classList.remove('hidden');
            document.getElementById('collection-view').classList.add('hidden');
            currentCollectionId = null;
            currentCollection = null;
            loadCollections();
        }

        async function showMatchup() {
            document.getElementById('matchup-section').classList.remove('hidden');
            document.getElementById('rankings-section').classList.add('hidden');
            document.getElementById('fixed-triangles-section').classList.add('hidden');
            await loadNextMatchup();
        }

        async function showRankings() {
            document.getElementById('matchup-section').classList.add('hidden');
            document.getElementById('rankings-section').classList.remove('hidden');
            document.getElementById('fixed-triangles-section').classList.add('hidden');
            await loadRankings();
        }

        async function showFixedTriangles() {
            document.getElementById('matchup-section').classList.add('hidden');
            document.getElementById('rankings-section').classList.add('hidden');
            document.getElementById('fixed-triangles-section').classList.remove('hidden');
            await loadTriangles();
        }

        async function loadTriangles() {
            const container = document.getElementById('triangles-container');
            container.innerHTML = '<div class="loading">Loading triangles...</div>';
            
            try {
                const response = await fetch(`/api/collections/${currentCollectionId}/triangles`);
                if (!response.ok) {
                    container.innerHTML = '<div class="loading">Error loading triangles</div>';
                    return;
                }
                
                const data = await response.json();
                
                if (!data.triangles || data.triangles.length === 0) {
                    container.innerHTML = '<div class="loading" style="padding: 40px; text-align: center; color: #666;">No triangles (cycles) found in this collection. All comparisons are consistent!</div>';
                    return;
                }
                
                let html = '<div style="display: flex; flex-direction: column; gap: 20px;">';
                
                for (const triangle of data.triangles) {
                    html += `
                        <div style="border: 2px solid #667eea; border-radius: 8px; padding: 20px; background: #f8f9fa;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                <h4 style="margin: 0; color: #667eea;">Triangle (Dissonance: ${triangle.dissonance.toFixed(2)})</h4>
                                <button onclick="showTriangleOptions(${triangle.item_a.id}, ${triangle.item_b.id}, ${triangle.item_c.id})" 
                                        style="padding: 8px 16px; font-size: 0.9em;">Resolve</button>
                            </div>
                            <div style="display: flex; flex-direction: column; gap: 10px;">
                                <div><strong>${escapeHtml(triangle.item_a.name)}</strong> (${triangle.item_a.points > 0 ? '+' : ''}${triangle.item_a.points} pts)</div>
                                <div><strong>${escapeHtml(triangle.item_b.name)}</strong> (${triangle.item_b.points > 0 ? '+' : ''}${triangle.item_b.points} pts)</div>
                                <div><strong>${escapeHtml(triangle.item_c.name)}</strong> (${triangle.item_c.points > 0 ? '+' : ''}${triangle.item_c.points} pts)</div>
                            </div>
                        </div>
                    `;
                }
                
                html += '</div>';
                container.innerHTML = html;
            } catch (error) {
                console.error('Error loading triangles:', error);
                container.innerHTML = '<div class="loading">Error loading triangles</div>';
            }
        }

        async function showTriangleOptions(item_a_id, item_b_id, item_c_id) {
            try {
                const response = await fetch(`/api/collections/${currentCollectionId}/triangles/${item_a_id}/${item_b_id}/${item_c_id}/options`);
                if (!response.ok) {
                    alert('Error loading resolution options');
                    return;
                }
                
                const data = await response.json();
                
                // Get item names
                const collectionResponse = await fetch(`/api/collections/${currentCollectionId}`);
                const collection = await collectionResponse.json();
                const items_dict = {};
                collection.items.forEach(item => {
                    items_dict[item.id] = item;
                });
                
                const item_a_name = items_dict[item_a_id]?.name || 'Item A';
                const item_b_name = items_dict[item_b_id]?.name || 'Item B';
                const item_c_name = items_dict[item_c_id]?.name || 'Item C';
                
                // Create dialog
                let dialogHTML = `
                    <div id="triangle-options-dialog" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 2000; display: flex; align-items: center; justify-content: center; overflow-y: auto;">
                        <div class="card" style="max-width: 800px; max-height: 90vh; overflow-y: auto; margin: 20px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                                <h3 class="section-title" style="margin: 0;">Resolution Options</h3>
                                <button onclick="closeTriangleOptionsDialog()" style="background: none; border: none; font-size: 1.5em; cursor: pointer; color: #666;">√ó</button>
                            </div>
                            <div style="margin-bottom: 15px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                                <strong>Triangle:</strong> ${escapeHtml(item_a_name)}, ${escapeHtml(item_b_name)}, ${escapeHtml(item_c_name)}
                            </div>
                            <div id="triangle-options-list" style="display: flex; flex-direction: column; gap: 15px;">
                `;
                
                for (let i = 0; i < data.options.length; i++) {
                    const option = data.options[i];
                    const ordering = option.ordering;
                    const firstItem = items_dict[ordering[0].item_id];
                    const secondItem = items_dict[ordering[1].item_id];
                    const thirdItem = items_dict[ordering[2].item_id];
                    
                    const dissonanceChange = option.dissonance_change;
                    const changeColor = dissonanceChange < 0 ? '#28a745' : dissonanceChange > 0 ? '#dc3545' : '#6c757d';
                    const changeSymbol = dissonanceChange < 0 ? '‚Üì' : dissonanceChange > 0 ? '‚Üë' : '=';
                    
                    dialogHTML += `
                        <div style="border: 2px solid #ddd; border-radius: 6px; padding: 15px; background: white;">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                                <div>
                                    <strong>Option ${i + 1}:</strong>
                                    <div style="margin-top: 5px; color: #666;">
                                        1st: ${escapeHtml(firstItem.name)}<br>
                                        2nd: ${escapeHtml(secondItem.name)}<br>
                                        3rd: ${escapeHtml(thirdItem.name)}
                                    </div>
                                </div>
                                <div style="text-align: right;">
                                    <div style="color: ${changeColor}; font-weight: bold; font-size: 1.1em;">
                                        ${changeSymbol} ${Math.abs(dissonanceChange).toFixed(2)}
                                    </div>
                                    <div style="font-size: 0.85em; color: #666;">
                                        Dissonance change
                                    </div>
                                </div>
                            </div>
                            <button onclick="resolveTriangle(${item_a_id}, ${item_b_id}, ${item_c_id}, ${i})" 
                                    style="width: 100%; padding: 10px; font-size: 0.95em; ${dissonanceChange < 0 ? 'background: #28a745;' : ''}">
                                Select This Resolution
                            </button>
                        </div>
                    `;
                }
                
                dialogHTML += `
                            </div>
                        </div>
                    </div>
                `;
                
                // Remove existing dialog if any
                const existing = document.getElementById('triangle-options-dialog');
                if (existing) {
                    existing.remove();
                }
                
                document.body.insertAdjacentHTML('beforeend', dialogHTML);
                
                // Store options data for resolution
                window.currentTriangleOptions = {
                    item_a_id: item_a_id,
                    item_b_id: item_b_id,
                    item_c_id: item_c_id,
                    options: data.options
                };
            } catch (error) {
                console.error('Error loading triangle options:', error);
                alert('Error loading resolution options');
            }
        }

        function closeTriangleOptionsDialog() {
            const dialog = document.getElementById('triangle-options-dialog');
            if (dialog) {
                dialog.remove();
            }
            window.currentTriangleOptions = null;
        }

        async function resolveTriangle(item_a_id, item_b_id, item_c_id, optionIndex) {
            if (!window.currentTriangleOptions) {
                alert('Error: Triangle options not loaded');
                return;
            }
            
            const option = window.currentTriangleOptions.options[optionIndex];
            const resolution = option.resolution;
            
            try {
                const response = await fetch(`/api/collections/${currentCollectionId}/triangles/resolve`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        item_a_id: item_a_id,
                        item_b_id: item_b_id,
                        item_c_id: item_c_id,
                        resolution: resolution
                    })
                });
                
                if (response.ok) {
                    closeTriangleOptionsDialog();
                    await loadTriangles(); // Reload triangles list
                    await loadRankings(); // Update rankings
                    alert('Triangle resolved successfully!');
                } else {
                    const error = await response.json();
                    alert(`Error resolving triangle: ${error.error || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Error resolving triangle:', error);
                alert('Error resolving triangle');
            }
        }

        async function loadNextMatchup(specificItem1Id = null, specificItem2Id = null) {
            const container = document.getElementById('matchup-container');
            container.innerHTML = '<div class="loading">Loading next matchup...</div>';
            
            try {
                let url = `/api/collections/${currentCollectionId}/matchup`;
                // If specific items requested, add them as query parameters
                if (specificItem1Id && specificItem2Id) {
                    url += `?item1_id=${specificItem1Id}&item2_id=${specificItem2Id}`;
                }
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.message) {
                    container.innerHTML = `<div class="loading">${data.message}</div>`;
                    return;
                }
                
                // Build video embeds if media links exist
                const video1 = data.item1.media_link ? getYouTubeEmbed(data.item1.media_link) : '';
                const video2 = data.item2.media_link ? getYouTubeEmbed(data.item2.media_link) : '';
                
                // Get search prefix for YouTube search links
                const searchPrefix = currentCollection ? (currentCollection.search_prefix || '') : '';
                const searchUrl1 = getYouTubeSearchUrl(searchPrefix, data.item1.name);
                const searchUrl2 = getYouTubeSearchUrl(searchPrefix, data.item2.name);
                
                container.innerHTML = `
                    <div class="matchup-items-row">
                        <div class="matchup-item" id="item1-container">
                            <div class="matchup-item-content" style="display: flex; flex-direction: column; gap: 15px;">
                                <div style="display: flex; justify-content: center; gap: 5px; flex-wrap: wrap;">
                                    <a href="${escapeHtml(searchUrl1)}" target="_blank" style="padding: 4px 8px; font-size: 0.8em; background: #dc3545; color: white; text-decoration: none; border-radius: 4px;">üîç Search</a>
                                    <button onclick="autoFillYouTube(${data.item1.id}, event)" style="padding: 4px 8px; font-size: 0.8em; background: #28a745; color: white;">ü§ñ Auto YT</button>
                                    <button onclick="toggleEditItem(${data.item1.id}, event)" style="padding: 4px 8px; font-size: 0.8em;">‚úèÔ∏è Edit</button>
                                </div>
                                <div style="font-size: 1.2em; font-weight: bold; text-align: center;">${escapeHtml(data.item1.name)}</div>
                                ${video1 ? `<div>${video1}</div>` : ''}
                            </div>
                        </div>
                        <div class="matchup-vs">VS</div>
                        <div class="matchup-item" id="item2-container">
                            <div class="matchup-item-content" style="display: flex; flex-direction: column; gap: 15px;">
                                <div style="display: flex; justify-content: center; gap: 5px; flex-wrap: wrap;">
                                    <a href="${escapeHtml(searchUrl2)}" target="_blank" style="padding: 4px 8px; font-size: 0.8em; background: #dc3545; color: white; text-decoration: none; border-radius: 4px;">üîç Search</a>
                                    <button onclick="autoFillYouTube(${data.item2.id}, event)" style="padding: 4px 8px; font-size: 0.8em; background: #28a745; color: white;">ü§ñ Auto YT</button>
                                    <button onclick="toggleEditItem(${data.item2.id}, event)" style="padding: 4px 8px; font-size: 0.8em;">‚úèÔ∏è Edit</button>
                                </div>
                                <div style="font-size: 1.2em; font-weight: bold; text-align: center;">${escapeHtml(data.item2.name)}</div>
                                ${video2 ? `<div>${video2}</div>` : ''}
                            </div>
                        </div>
                    </div>
                    <div class="matchup-buttons" style="margin-top: 30px;">
                        <button onclick="selectVote('item1')" id="select-item1" class="vote-select-btn">${escapeHtml(data.item1.name)} Wins</button>
                        <button onclick="selectVote('tie')" id="select-tie" class="vote-select-btn secondary">Tie</button>
                        <button onclick="selectVote('item2')" id="select-item2" class="vote-select-btn">${escapeHtml(data.item2.name)} Wins</button>
                    </div>
                    <div id="submit-vote-section" class="hidden" style="margin-top: 20px; text-align: center;">
                        <div style="margin-bottom: 15px; padding: 15px; background: #f8f9fa; border-radius: 6px; border-left: 4px solid #667eea;">
                            <strong>Selected:</strong> <span id="selected-vote-text"></span>
                        </div>
                        <button onclick="submitSelectedVote()" id="submit-vote-btn" style="padding: 12px 32px; font-size: 1.1em;">Submit Vote</button>
                    </div>
                    <div style="width: 100%; margin-top: 30px; padding-top: 20px; border-top: 2px solid #ddd; text-align: center;">
                        <button onclick="revealScores()" style="padding: 10px 20px; font-size: 0.95em; background: #6c757d; color: white;">üìä Reveal Scores</button>
                        ${window.lastVote ? `
                        <button onclick="changeLastVote()" style="padding: 10px 20px; font-size: 0.95em; background: #ffc107; color: #000; margin-left: 10px;">‚Ü©Ô∏è Revise Last Vote</button>
                        ` : ''}
                    </div>
                `;
                
                // Set up edit section for both items
                setupMatchupEditSection(data.item1, data.item2);
                
                window.currentMatchup = {
                    item1_id: data.item1.id,
                    item2_id: data.item2.id,
                    item1_name: data.item1.name,
                    item2_name: data.item2.name,
                    item1_media_link: data.item1.media_link,
                    item2_media_link: data.item2.media_link
                };
                
                // Clear selected vote when loading new matchup
                selectedVote = null;
                
                // Keep last vote info - don't clear it, just update it when we vote
            } catch (error) {
                console.error('Error loading matchup:', error);
                container.innerHTML = '<div class="loading">Error loading matchup</div>';
            }
        }


        let selectedVote = null;

        function selectVote(winner) {
            selectedVote = winner;
            
            // Remove selected class from all buttons
            document.querySelectorAll('.vote-select-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            
            // Add selected class to clicked button
            const buttonId = winner === 'item1' ? 'select-item1' : winner === 'item2' ? 'select-item2' : 'select-tie';
            const button = document.getElementById(buttonId);
            if (button) {
                button.classList.add('selected');
            }
            
            // Show submit section
            const submitSection = document.getElementById('submit-vote-section');
            if (submitSection) {
                submitSection.classList.remove('hidden');
            }
            
            // Update selected vote text
            const voteText = document.getElementById('selected-vote-text');
            if (voteText) {
                if (winner === 'item1') {
                    voteText.textContent = window.currentMatchup ? `${window.currentMatchup.item1_name} Wins` : 'A Wins';
                } else if (winner === 'item2') {
                    voteText.textContent = window.currentMatchup ? `${window.currentMatchup.item2_name} Wins` : 'B Wins';
                } else {
                    voteText.textContent = 'Tie';
                }
            }
        }

        async function submitSelectedVote() {
            if (!selectedVote || !window.currentMatchup) {
                alert('Please select a vote option first');
                return;
            }
            
            await submitMatchup(selectedVote);
            selectedVote = null; // Clear selection after submission
        }

        async function submitMatchup(winner) {
            if (!window.currentMatchup) return;
            
            const result = winner === 'item1' ? 'item1' : winner === 'item2' ? 'item2' : 'tie';
            
            // Store last vote info for quick change option
            window.lastVote = {
                item1_id: window.currentMatchup.item1_id,
                item2_id: window.currentMatchup.item2_id,
                item1_name: window.currentMatchup.item1_name,
                item2_name: window.currentMatchup.item2_name,
                winner: result
            };
            
            try {
                const response = await fetch(`/api/collections/${currentCollectionId}/matchup`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        item1_id: window.currentMatchup.item1_id,
                        item2_id: window.currentMatchup.item2_id,
                        winner: result
                    })
                });
                
                if (response.ok) {
                    await loadRankings(); // Update rankings
                    await loadNextMatchup(); // Load next matchup
                } else {
                    alert('Error submitting matchup');
                    window.lastVote = null; // Clear on error
                }
            } catch (error) {
                console.error('Error submitting matchup:', error);
                alert('Error submitting matchup');
                window.lastVote = null; // Clear on error
            }
        }

        async function revealScores() {
            if (!window.currentMatchup) {
                alert('No matchup loaded');
                return;
            }
            
            try {
                // Fetch collection data to get item scores
                const response = await fetch(`/api/collections/${currentCollectionId}`);
                const collection = await response.json();
                
                // Find items in the collection
                const item1 = collection.items.find(i => i.id === window.currentMatchup.item1_id);
                const item2 = collection.items.find(i => i.id === window.currentMatchup.item2_id);
                
                if (!item1 || !item2) {
                    alert('Could not find item scores');
                    return;
                }
                
                // Format scores
                let score1Display = `${item1.points > 0 ? '+' : ''}${item1.points}`;
                let score2Display = `${item2.points > 0 ? '+' : ''}${item2.points}`;
                
                if (item1.sub_scores && item1.sub_scores.length > 1) {
                    const formattedScores = item1.sub_scores.map(score => {
                        return score > 0 ? `+${score}` : `${score}`;
                    });
                    score1Display = formattedScores.join(' / ');
                }
                
                if (item2.sub_scores && item2.sub_scores.length > 1) {
                    const formattedScores = item2.sub_scores.map(score => {
                        return score > 0 ? `+${score}` : `${score}`;
                    });
                    score2Display = formattedScores.join(' / ');
                }
                
                // Create and show popup
                showScorePopup(window.currentMatchup.item1_name, score1Display, window.currentMatchup.item2_name, score2Display);
            } catch (error) {
                console.error('Error revealing scores:', error);
                alert('Error revealing scores');
            }
        }

        function showScorePopup(item1Name, item1Score, item2Name, item2Score) {
            // Remove existing popup if any
            const existingPopup = document.getElementById('score-reveal-popup');
            if (existingPopup) {
                existingPopup.remove();
            }
            
            // Create popup
            const popup = document.createElement('div');
            popup.id = 'score-reveal-popup';
            popup.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 2000; display: flex; align-items: center; justify-content: center;';
            
            popup.innerHTML = `
                <div class="card" style="max-width: 500px; width: 90%; position: relative;">
                    <button onclick="closeScorePopup()" style="position: absolute; top: 10px; right: 10px; background: none; border: none; font-size: 1.5em; cursor: pointer; color: #666; padding: 0; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center;">√ó</button>
                    <h3 class="section-title" style="margin-top: 0;">Current Scores</h3>
                    <div style="display: flex; flex-direction: column; gap: 20px; margin-top: 20px;">
                        <div style="padding: 15px; background: #f8f9fa; border-radius: 6px; border-left: 4px solid #667eea;">
                            <div style="font-weight: bold; margin-bottom: 5px; color: #667eea;">${escapeHtml(item1Name)}</div>
                            <div style="font-size: 1.3em; font-weight: bold; color: #333;">${escapeHtml(item1Score)} pts</div>
                        </div>
                        <div style="padding: 15px; background: #f8f9fa; border-radius: 6px; border-left: 4px solid #667eea;">
                            <div style="font-weight: bold; margin-bottom: 5px; color: #667eea;">${escapeHtml(item2Name)}</div>
                            <div style="font-size: 1.3em; font-weight: bold; color: #333;">${escapeHtml(item2Score)} pts</div>
                        </div>
                    </div>
                    <div style="margin-top: 20px; text-align: center;">
                        <button onclick="closeScorePopup()" style="padding: 10px 30px;">OK</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(popup);
            
            // Close on outside click
            popup.addEventListener('click', (e) => {
                if (e.target === popup) {
                    closeScorePopup();
                }
            });
        }

        function closeScorePopup() {
            const popup = document.getElementById('score-reveal-popup');
            if (popup) {
                popup.remove();
            }
        }

        async function loadRankings() {
            try {
                const response = await fetch(`/api/collections/${currentCollectionId}`);
                const collection = await response.json();
                
                const listEl = document.getElementById('rankings-list');
                listEl.innerHTML = '';
                
                const totalItems = collection.items.length;
                const totalComparisons = collection.comparisons_count;
                const maxComparisons = (totalItems * (totalItems - 1)) / 2;
                
                // Update stats
                const statsEl = document.getElementById('stats');
                statsEl.classList.remove('hidden');
                statsEl.innerHTML = `
                    <div class="stat-card">
                        <div class="value">${totalItems}</div>
                        <div class="label">Total Items</div>
                    </div>
                    <div class="stat-card">
                        <div class="value">${totalComparisons}</div>
                        <div class="label">Comparisons Made</div>
                    </div>
                    <div class="stat-card">
                        <div class="value">${maxComparisons}</div>
                        <div class="label">Max Comparisons</div>
                    </div>
                    <div class="stat-card">
                        <div class="value">${maxComparisons > 0 ? Math.round((totalComparisons / maxComparisons) * 100) : 0}%</div>
                        <div class="label">Progress</div>
                    </div>
                `;
                
                // Load and render histogram
                await loadHistogram();
                
                const searchPrefix = collection.search_prefix || '';
                
                collection.items.forEach((item, index) => {
                    const li = document.createElement('li');
                    const pointsClass = item.points > 0 ? 'positive' : item.points < 0 ? 'negative' : '';
                    const editingId = `item-${item.id}`;
                    const searchUrl = getYouTubeSearchUrl(searchPrefix, item.name);
                    
                    // Format score display with sub-scores if available
                    let scoreDisplay = `${item.points > 0 ? '+' : ''}${item.points}`;
                    if (item.sub_scores && item.sub_scores.length > 1) {
                        // Format as X / Y / Z / ...
                        const formattedScores = item.sub_scores.map(score => {
                            return score > 0 ? `+${score}` : `${score}`;
                        });
                        scoreDisplay = formattedScores.join(' / ');
                    }
                    scoreDisplay += ' pts';
                    
                    li.innerHTML = `
                        <div style="flex: 1; display: flex; flex-direction: column;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span class="rank-number">#${index + 1}</span>
                                <span class="item-name" id="item-name-${item.id}">${escapeHtml(item.name)}</span>
                                <span class="item-points ${pointsClass}">${scoreDisplay}</span>
                            </div>
                            <div id="item-edit-${item.id}" class="hidden">
                                <div class="edit-form">
                                    <input type="text" id="item-name-input-${item.id}" value="${escapeHtml(item.name)}" placeholder="Item name">
                                    <input type="text" id="item-media-input-${item.id}" value="${item.media_link || ''}" placeholder="YouTube link (optional)">
                                    <button onclick="saveItemEdit(${item.id})">Save</button>
                                    <button class="secondary" onclick="cancelItemEdit(${item.id})">Cancel</button>
                                </div>
                            </div>
                            <div id="item-display-${item.id}">
                                ${item.media_link ? (() => {
                                    const normalizedUrl = normalizeYouTubeUrl(item.media_link);
                                    const displayText = item.media_link;
                                    return `<div class="media-link-display">üìé <a href="${escapeHtml(normalizedUrl)}" target="_blank">${escapeHtml(displayText)}</a></div>`;
                                })() : ''}
                                <div class="item-actions">
                                    <a href="${escapeHtml(searchUrl)}" target="_blank" style="padding: 6px 12px; font-size: 0.85em; background: #dc3545; color: white; text-decoration: none; border-radius: 4px; display: inline-block;">üîç Search YouTube</a>
                                    <button onclick="autoFillYouTube(${item.id}, event)" style="padding: 6px 12px; font-size: 0.85em; background: #28a745; color: white;">ü§ñ Auto YT</button>
                                    <button onclick="editItem(${item.id})" style="padding: 6px 12px; font-size: 0.85em;">‚úèÔ∏è Edit</button>
                                    <button onclick="viewItemVotes(${item.id})" style="padding: 6px 12px; font-size: 0.85em;">üìä View Votes</button>
                                </div>
                            </div>
                        </div>
                    `;
                    listEl.appendChild(li);
                });
            } catch (error) {
                console.error('Error loading rankings:', error);
                alert('Error loading rankings');
            }
        }

        async function deleteCollection(id) {
            if (!confirm('Are you sure you want to delete this collection?')) {
                return;
            }
            
            try {
                const response = await fetch(`/api/collections/${id}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    if (currentCollectionId === id) {
                        showCollections();
                    } else {
                        loadCollections();
                    }
                } else {
                    alert('Error deleting collection');
                }
            } catch (error) {
                console.error('Error deleting collection:', error);
                alert('Error deleting collection');
            }
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function normalizeYouTubeUrl(url) {
            if (!url) return '';
            
            const trimmed = url.trim();
            
            // If it's already a full URL, return as-is
            if (trimmed.startsWith('http://') || trimmed.startsWith('https://')) {
                return trimmed;
            }
            
            // Check if it looks like a YouTube video ID (11 characters, alphanumeric + _ and -)
            const videoIdPattern = /^([a-zA-Z0-9_-]{11})$/;
            if (videoIdPattern.test(trimmed)) {
                // Convert video ID to full YouTube URL
                return `https://www.youtube.com/watch?v=${trimmed}`;
            }
            
            // If it's not a video ID and doesn't have a protocol, assume it's not a valid URL
            // Return as-is (user might want to fix it)
            return trimmed;
        }

        function getYouTubeEmbed(url) {
            if (!url) return '';
            
            // Extract YouTube video ID from various URL formats
            let videoId = null;
            
            // Standard formats: https://www.youtube.com/watch?v=VIDEO_ID
            // or https://youtu.be/VIDEO_ID
            // or https://www.youtube.com/embed/VIDEO_ID
            const patterns = [
                /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
                /^([a-zA-Z0-9_-]{11})$/ // Just the video ID
            ];
            
            for (const pattern of patterns) {
                const match = url.match(pattern);
                if (match) {
                    videoId = match[1];
                    break;
                }
            }
            
            if (!videoId) {
                // If not a YouTube URL, normalize it first to ensure it's a valid link
                const normalizedUrl = normalizeYouTubeUrl(url);
                return `<div class="media-link-display" style="margin-top: 10px;">
                    <a href="${escapeHtml(normalizedUrl)}" target="_blank">üîó Open Media Link</a>
                </div>`;
            }
            
            return `<div class="video-container">
                <iframe src="https://www.youtube.com/embed/${videoId}" 
                    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                    allowfullscreen>
                </iframe>
            </div>`;
        }

        function editItem(itemId) {
            document.getElementById(`item-display-${itemId}`).classList.add('hidden');
            document.getElementById(`item-edit-${itemId}`).classList.remove('hidden');
        }

        function cancelItemEdit(itemId) {
            document.getElementById(`item-display-${itemId}`).classList.remove('hidden');
            document.getElementById(`item-edit-${itemId}`).classList.add('hidden');
        }

        async function saveItemEdit(itemId) {
            const nameInput = document.getElementById(`item-name-input-${itemId}`);
            const mediaInput = document.getElementById(`item-media-input-${itemId}`);
            
            const name = nameInput.value.trim();
            let mediaLink = mediaInput.value.trim();
            
            // Normalize YouTube URLs before saving
            if (mediaLink) {
                mediaLink = normalizeYouTubeUrl(mediaLink);
            }
            
            if (!name) {
                alert('Item name cannot be empty');
                return;
            }
            
            try {
                const response = await fetch(`/api/items/${itemId}`, {
                    method: 'PUT',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        name: name,
                        media_link: mediaLink || null
                    })
                });
                
                if (response.ok) {
                    // Reload rankings to reflect changes
                    await loadRankings();
                } else {
                    alert('Error updating item');
                }
            } catch (error) {
                console.error('Error updating item:', error);
                alert('Error updating item');
            }
        }

        async function addItemsToCollection() {
            const itemsInput = document.getElementById('new-items-input');
            const itemsText = itemsInput.value.trim();
            
            if (!itemsText) {
                alert('Please enter at least one item');
                return;
            }
            
            try {
                const response = await fetch(`/api/collections/${currentCollectionId}/items`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({items: itemsText})
                });
                
                if (response.ok) {
                    const data = await response.json();
                    itemsInput.value = '';
                    alert(`Successfully added ${data.added} item(s)`);
                    await loadRankings(); // Refresh rankings
                } else {
                    alert('Error adding items');
                }
            } catch (error) {
                console.error('Error adding items:', error);
                alert('Error adding items');
            }
        }

        function toggleExportMenu() {
            const menu = document.getElementById('export-menu');
            if (menu.classList.contains('hidden')) {
                menu.classList.remove('hidden');
                menu.style.display = 'block';
                // Close menu when clicking outside
                setTimeout(() => {
                    document.addEventListener('click', closeExportMenuOnOutsideClick, true);
                }, 0);
            } else {
                closeExportMenu();
            }
        }

        function closeExportMenu() {
            const menu = document.getElementById('export-menu');
            menu.classList.add('hidden');
            menu.style.display = 'none';
            document.removeEventListener('click', closeExportMenuOnOutsideClick, true);
        }

        function closeExportMenuOnOutsideClick(event) {
            const menu = document.getElementById('export-menu');
            if (!menu.contains(event.target) && event.target.onclick !== toggleExportMenu) {
                closeExportMenu();
            }
        }

        async function getCollectionExportData() {
            if (!currentCollectionId) return null;
            
            const response = await fetch(`/api/collections/${currentCollectionId}/export`);
            if (!response.ok) {
                throw new Error('Error exporting collection');
            }
            
            const data = await response.json();
            return JSON.stringify(data, null, 2);
        }

        async function exportCollectionToFile(event) {
            if (event) event.stopPropagation();
            closeExportMenu();
            
            try {
                const jsonStr = await getCollectionExportData();
                if (!jsonStr) return;
                
                // Create download link
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ranqr-${currentCollection.name.replace(/[^a-z0-9]/gi, '_')}-${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Error exporting collection:', error);
                alert('Error exporting collection');
            }
        }

        async function exportCollectionToClipboard(event) {
            if (event) event.stopPropagation();
            closeExportMenu();
            
            const button = event ? event.target : null;
            const originalText = button ? button.textContent : '';
            
            try {
                const jsonStr = await getCollectionExportData();
                if (!jsonStr) return;
                
                // Copy to clipboard
                await navigator.clipboard.writeText(jsonStr);
                
                // Show success feedback
                if (button) {
                    button.textContent = '‚úì Copied!';
                    button.style.background = '#28a745';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.background = '';
                    }, 2000);
                } else {
                    alert('Copied to clipboard!');
                }
            } catch (error) {
                console.error('Error copying to clipboard:', error);
                // Fallback for older browsers
                try {
                    const jsonStr = await getCollectionExportData();
                    if (jsonStr) {
                        const textArea = document.createElement('textarea');
                        textArea.value = jsonStr;
                        textArea.style.position = 'fixed';
                        textArea.style.opacity = '0';
                        document.body.appendChild(textArea);
                        textArea.select();
                        try {
                            document.execCommand('copy');
                            alert('Copied to clipboard!');
                        } catch (err) {
                            alert('Failed to copy. Please copy manually.');
                        }
                        document.body.removeChild(textArea);
                    }
                } catch (err) {
                    alert('Error copying to clipboard');
                }
            }
        }

        function showCreateDialog() {
            document.getElementById('create-collection-form').classList.remove('hidden');
            document.getElementById('collection-name').focus();
        }

        function hideCreateDialog() {
            document.getElementById('create-collection-form').classList.add('hidden');
            document.getElementById('collection-name').value = '';
            document.getElementById('search-prefix-input').value = '';
            document.getElementById('items-input').value = '';
        }

        function showImportDialog() {
            document.getElementById('import-dialog').classList.remove('hidden');
            document.getElementById('import-dialog').style.display = 'flex';
            document.getElementById('import-json-input').focus();
        }

        function hideImportDialog() {
            document.getElementById('import-dialog').classList.add('hidden');
            document.getElementById('import-dialog').style.display = 'none';
            document.getElementById('import-json-input').value = '';
        }

        async function importCollection() {
            const jsonInput = document.getElementById('import-json-input').value.trim();
            
            if (!jsonInput) {
                alert('Please paste JSON data');
                return;
            }
            
            try {
                const data = JSON.parse(jsonInput);
                
                const response = await fetch('/api/collections/import', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(data)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    hideImportDialog();
                    alert(`Successfully imported collection! ${result.items_imported} items, ${result.comparisons_imported} comparisons.`);
                    // Refresh collections list and open the new collection
                    loadCollections();
                    // Small delay to ensure collection is saved
                    setTimeout(() => {
                        openCollection(result.collection_id);
                    }, 500);
                } else {
                    const error = await response.json();
                    alert(`Error importing: ${error.error || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Error importing collection:', error);
                alert('Error importing collection. Please check the JSON format.');
            }
        }

        let currentVotesItemId = null;

        async function viewItemVotes(itemId) {
            currentVotesItemId = itemId;
            
            try {
                const response = await fetch(`/api/items/${itemId}/votes`);
                if (!response.ok) {
                    alert('Error loading voting history');
                    return;
                }
                
                const data = await response.json();
                
                // Update dialog header
                document.getElementById('votes-item-name').textContent = `Voting History: ${data.item.name}`;
                document.getElementById('votes-wins-count').textContent = data.wins.length;
                document.getElementById('votes-losses-count').textContent = data.losses.length;
                document.getElementById('votes-ties-count').textContent = data.ties.length;
                document.getElementById('votes-points').textContent = data.item.points;
                
                // Render wins
                const winsList = document.getElementById('votes-wins-list');
                winsList.innerHTML = '';
                if (data.wins.length === 0) {
                    winsList.innerHTML = '<p style="color: #666; font-style: italic;">No wins yet</p>';
                } else {
                    data.wins.forEach(win => {
                        const card = document.createElement('div');
                        card.className = 'vote-item-card win';
                        card.innerHTML = `
                            <span class="vote-item-name">${escapeHtml(win.other_item_name)}</span>
                            <span class="vote-item-action" onclick="changeVote(${itemId}, ${win.other_item_id}, event)">Change Vote</span>
                        `;
                        winsList.appendChild(card);
                    });
                }
                
                // Render losses
                const lossesList = document.getElementById('votes-losses-list');
                lossesList.innerHTML = '';
                if (data.losses.length === 0) {
                    lossesList.innerHTML = '<p style="color: #666; font-style: italic;">No losses yet</p>';
                } else {
                    data.losses.forEach(loss => {
                        const card = document.createElement('div');
                        card.className = 'vote-item-card loss';
                        card.innerHTML = `
                            <span class="vote-item-name">${escapeHtml(loss.other_item_name)}</span>
                            <span class="vote-item-action" onclick="changeVote(${itemId}, ${loss.other_item_id}, event)">Change Vote</span>
                        `;
                        lossesList.appendChild(card);
                    });
                }
                
                // Render ties
                const tiesList = document.getElementById('votes-ties-list');
                tiesList.innerHTML = '';
                if (data.ties.length === 0) {
                    tiesList.innerHTML = '<p style="color: #666; font-style: italic;">No ties yet</p>';
                } else {
                    data.ties.forEach(tie => {
                        const card = document.createElement('div');
                        card.className = 'vote-item-card tie';
                        card.innerHTML = `
                            <span class="vote-item-name">${escapeHtml(tie.other_item_name)}</span>
                            <span class="vote-item-action" onclick="changeVote(${itemId}, ${tie.other_item_id}, event)">Change Vote</span>
                        `;
                        tiesList.appendChild(card);
                    });
                }
                
                // Show dialog
                document.getElementById('votes-dialog').classList.remove('hidden');
                document.getElementById('votes-dialog').style.display = 'flex';
            } catch (error) {
                console.error('Error loading voting history:', error);
                alert('Error loading voting history');
            }
        }

        function hideVotesDialog() {
            document.getElementById('votes-dialog').classList.add('hidden');
            document.getElementById('votes-dialog').style.display = 'none';
            currentVotesItemId = null;
        }

        async function changeVote(itemXId, itemYId, event) {
            if (event) event.stopPropagation();
            
            // Get item names for better prompt
            const collectionResponse = await fetch(`/api/collections/${currentCollectionId}`);
            const collection = await collectionResponse.json();
            const itemX = collection.items.find(i => i.id === itemXId);
            const itemY = collection.items.find(i => i.id === itemYId);
            
            const itemXName = itemX ? itemX.name : 'Item X';
            const itemYName = itemY ? itemY.name : 'Item Y';
            
            // Show a simple prompt to change the vote
            const newResult = prompt(`Change vote between:\n"${itemXName}" vs "${itemYName}"\n\n1 = "${itemXName}" wins\n2 = "${itemYName}" wins\n3 = Tie\n\nEnter 1, 2, or 3:`);
            
            if (!newResult) return;
            
            let winner;
            if (newResult === '1') {
                winner = 'item1'; // X wins
            } else if (newResult === '2') {
                winner = 'item2'; // Y wins
            } else if (newResult === '3') {
                winner = 'tie';
            } else {
                alert('Invalid choice. Please enter 1, 2, or 3.');
                return;
            }
            
            // Determine which is item1 and item2 for the API
            const item1_id = Math.min(itemXId, itemYId);
            const item2_id = Math.max(itemXId, itemYId);
            
            // Adjust winner if IDs were swapped
            let adjustedWinner = winner;
            if (itemXId > itemYId) {
                if (winner === 'item1') {
                    adjustedWinner = 'item2';
                } else if (winner === 'item2') {
                    adjustedWinner = 'item1';
                }
            }
            
            try {
                const response = await fetch(`/api/collections/${currentCollectionId}/matchup`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        item1_id: item1_id,
                        item2_id: item2_id,
                        winner: adjustedWinner
                    })
                });
                
                if (response.ok) {
                    // Refresh voting history and rankings
                    await viewItemVotes(itemXId);
                    await loadRankings();
                } else {
                    alert('Error updating vote');
                }
            } catch (error) {
                console.error('Error updating vote:', error);
                alert('Error updating vote');
            }
        }

        async function changeLastVote() {
            if (!window.lastVote) {
                alert('No previous vote to change');
                return;
            }
            
            const itemXId = window.lastVote.item1_id;
            const itemYId = window.lastVote.item2_id;
            const itemXName = window.lastVote.item1_name;
            const itemYName = window.lastVote.item2_name;
            
            // Show prompt with current result pre-selected
            let currentChoice = '3'; // Default to tie
            if (window.lastVote.winner === 'item1') {
                currentChoice = '1';
            } else if (window.lastVote.winner === 'item2') {
                currentChoice = '2';
            }
            
            const promptText = `Change last vote:\n"${itemXName}" vs "${itemYName}"\n\nCurrent: ${window.lastVote.winner === 'item1' ? `"${itemXName}" won` : window.lastVote.winner === 'item2' ? `"${itemYName}" won` : 'Tie'}\n\n1 = "${itemXName}" wins\n2 = "${itemYName}" wins\n3 = Tie\n\nEnter 1, 2, or 3 (or Cancel to keep current):`;
            const newResult = prompt(promptText, currentChoice);
            
            if (!newResult) return; // User cancelled
            
            let winner;
            if (newResult === '1') {
                winner = 'item1';
            } else if (newResult === '2') {
                winner = 'item2';
            } else if (newResult === '3') {
                winner = 'tie';
            } else {
                alert('Invalid choice. Please enter 1, 2, or 3.');
                return;
            }
            
            // Check if vote actually changed
            if (winner === window.lastVote.winner) {
                alert('Vote unchanged');
                return;
            }
            
            // Determine which is item1 and item2 for the API
            const item1_id = Math.min(itemXId, itemYId);
            const item2_id = Math.max(itemXId, itemYId);
            
            // Adjust winner if IDs were swapped
            let adjustedWinner = winner;
            if (itemXId > itemYId) {
                if (winner === 'item1') {
                    adjustedWinner = 'item2';
                } else if (winner === 'item2') {
                    adjustedWinner = 'item1';
                }
            }
            
            try {
                const response = await fetch(`/api/collections/${currentCollectionId}/matchup`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        item1_id: item1_id,
                        item2_id: item2_id,
                        winner: adjustedWinner
                    })
                });
                
                if (response.ok) {
                    // Update last vote info
                    window.lastVote.winner = winner;
                    
                    // Reload rankings and current matchup
                    await loadRankings();
                    await loadNextMatchup();
                } else {
                    alert('Error updating vote');
                }
            } catch (error) {
                console.error('Error updating vote:', error);
                alert('Error updating vote');
            }
        }

        async function resetItemVotes() {
            if (!currentVotesItemId) return;
            
            if (!confirm('Are you sure you want to reset all votes for this item? This will remove all comparisons involving this item and cannot be undone.')) {
                return;
            }
            
            try {
                const response = await fetch(`/api/items/${currentVotesItemId}/votes`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    const result = await response.json();
                    alert(`Successfully reset ${result.comparisons_reset} comparison(s).`);
                    hideVotesDialog();
                    await loadRankings(); // Refresh rankings
                } else {
                    alert('Error resetting votes');
                }
            } catch (error) {
                console.error('Error resetting votes:', error);
                alert('Error resetting votes');
            }
        }

        function setupMatchupEditSection(item1, item2) {
            const editSection = document.getElementById('matchup-edit-section');
            const editItems = document.getElementById('matchup-edit-items');
            
            editItems.innerHTML = `
                <div id="edit-item-${item1.id}" class="hidden">
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #667eea;">
                        <div style="font-weight: bold; margin-bottom: 10px;">Edit: ${escapeHtml(item1.name)}</div>
                        <div class="form-group" style="margin-bottom: 10px;">
                            <label>Name:</label>
                            <input type="text" id="matchup-item-name-${item1.id}" value="${escapeHtml(item1.name)}" style="width: 100%; padding: 8px;">
                        </div>
                        <div class="form-group" style="margin-bottom: 10px;">
                            <label>Media Link (YouTube URL or video ID):</label>
                            <input type="text" id="matchup-item-media-${item1.id}" value="${item1.media_link || ''}" placeholder="Paste YouTube link here" style="width: 100%; padding: 8px;">
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button onclick="saveMatchupItemEdit(${item1.id})">Save</button>
                            <button class="secondary" onclick="cancelMatchupItemEdit(${item1.id})">Cancel</button>
                        </div>
                    </div>
                </div>
                <div id="edit-item-${item2.id}" class="hidden">
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #667eea;">
                        <div style="font-weight: bold; margin-bottom: 10px;">Edit: ${escapeHtml(item2.name)}</div>
                        <div class="form-group" style="margin-bottom: 10px;">
                            <label>Name:</label>
                            <input type="text" id="matchup-item-name-${item2.id}" value="${escapeHtml(item2.name)}" style="width: 100%; padding: 8px;">
                        </div>
                        <div class="form-group" style="margin-bottom: 10px;">
                            <label>Media Link (YouTube URL or video ID):</label>
                            <input type="text" id="matchup-item-media-${item2.id}" value="${item2.media_link || ''}" placeholder="Paste YouTube link here" style="width: 100%; padding: 8px;">
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button onclick="saveMatchupItemEdit(${item2.id})">Save</button>
                            <button class="secondary" onclick="cancelMatchupItemEdit(${item2.id})">Cancel</button>
                        </div>
                    </div>
                </div>
            `;
        }

        function toggleEditItem(itemId, event) {
            if (event) event.stopPropagation();
            
            const editDiv = document.getElementById(`edit-item-${itemId}`);
            const editSection = document.getElementById('matchup-edit-section');
            
            if (editDiv.classList.contains('hidden')) {
                // Show this item's edit form, hide others
                document.querySelectorAll('[id^="edit-item-"]').forEach(el => {
                    el.classList.add('hidden');
                });
                editDiv.classList.remove('hidden');
                editSection.classList.remove('hidden');
                
                // Focus on media link input
                const mediaInput = document.getElementById(`matchup-item-media-${itemId}`);
                if (mediaInput) {
                    setTimeout(() => mediaInput.focus(), 100);
                }
            } else {
                editDiv.classList.add('hidden');
                // Hide section if no edits are visible
                const visibleEdits = document.querySelectorAll('[id^="edit-item-"]:not(.hidden)');
                if (visibleEdits.length === 0) {
                    editSection.classList.add('hidden');
                }
            }
        }

        function cancelMatchupItemEdit(itemId) {
            const editDiv = document.getElementById(`edit-item-${itemId}`);
            const editSection = document.getElementById('matchup-edit-section');
            editDiv.classList.add('hidden');
            
            // Hide section if no edits are visible
            const visibleEdits = document.querySelectorAll('[id^="edit-item-"]:not(.hidden)');
            if (visibleEdits.length === 0) {
                editSection.classList.add('hidden');
            }
        }

        async function saveMatchupItemEdit(itemId) {
            const nameInput = document.getElementById(`matchup-item-name-${itemId}`);
            const mediaInput = document.getElementById(`matchup-item-media-${itemId}`);
            
            const name = nameInput.value.trim();
            let mediaLink = mediaInput.value.trim();
            
            // Normalize YouTube URLs
            if (mediaLink) {
                mediaLink = normalizeYouTubeUrl(mediaLink);
            }
            
            if (!name) {
                alert('Item name cannot be empty');
                return;
            }
            
            try {
                const response = await fetch(`/api/items/${itemId}`, {
                    method: 'PUT',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        name: name,
                        media_link: mediaLink || null
                    })
                });
                
                if (response.ok) {
                    // Close edit form
                    cancelMatchupItemEdit(itemId);
                    
                    // Reload the SAME matchup to show updated videos/names
                    // Preserve the current matchup instead of getting a new random one
                    if (window.currentMatchup && window.currentMatchup.item1_id && window.currentMatchup.item2_id) {
                        await loadNextMatchup(window.currentMatchup.item1_id, window.currentMatchup.item2_id);
                    } else {
                        // Fallback to new matchup if current matchup not available
                        await loadNextMatchup();
                    }
                } else {
                    alert('Error updating item');
                }
            } catch (error) {
                console.error('Error updating item:', error);
                alert('Error updating item');
            }
        }

        function editCollectionSearchPrefix() {
            const currentPrefix = currentCollection ? (currentCollection.search_prefix || '') : '';
            const newPrefix = prompt('Enter YouTube search prefix (e.g., artist name):', currentPrefix);
            
            if (newPrefix === null) return; // User cancelled
            
            const searchPrefix = newPrefix.trim() || null;
            
            fetch(`/api/collections/${currentCollectionId}`, {
                method: 'PUT',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({search_prefix: searchPrefix})
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Update current collection data
                    currentCollection.search_prefix = searchPrefix;
                    // Update display
                    const prefixDisplay = document.getElementById('search-prefix-value');
                    if (prefixDisplay) {
                        prefixDisplay.textContent = searchPrefix || 'None';
                    }
                    // Reload rankings to update search links
                    loadRankings();
                    // Reload matchup if it's visible to update search links
                    if (!document.getElementById('matchup-section').classList.contains('hidden')) {
                        loadNextMatchup();
                    }
                } else {
                    alert('Error updating search prefix');
                }
            })
            .catch(error => {
                console.error('Error updating search prefix:', error);
                alert('Error updating search prefix');
            });
        }

        async function autoFillYouTube(itemId, event) {
            if (event) event.stopPropagation();
            
            // Show loading state
            let buttonElement = null;
            const originalText = 'ü§ñ Auto YT';
            if (event && event.target) {
                buttonElement = event.target;
                buttonElement.disabled = true;
                buttonElement.textContent = '‚è≥ Loading...';
            }
            
            try {
                const response = await fetch(`/api/items/${itemId}/auto-youtube`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'}
                });
                
                const data = await response.json();
                
                if (response.ok && data.success) {
                    // Update was successful
                    // If we're in a matchup view, reload the same matchup to show the video
                    if (window.currentMatchup && window.currentMatchup.item1_id && window.currentMatchup.item2_id) {
                        await loadNextMatchup(window.currentMatchup.item1_id, window.currentMatchup.item2_id);
                    } else {
                        // Otherwise just reload rankings
                        await loadRankings();
                    }
                    
                    // Show success message briefly
                    if (buttonElement) {
                        buttonElement.textContent = '‚úì Done!';
                        setTimeout(() => {
                            if (buttonElement) {
                                buttonElement.textContent = originalText;
                                buttonElement.disabled = false;
                            }
                        }, 1500);
                    }
                } else {
                    alert(data.error || 'Could not automatically find YouTube video. Please search manually and add the link.');
                    if (buttonElement) {
                        buttonElement.textContent = originalText;
                        buttonElement.disabled = false;
                    }
                }
            } catch (error) {
                console.error('Error auto-filling YouTube:', error);
                alert('Error auto-filling YouTube video. Please try again or add manually.');
                if (buttonElement) {
                    buttonElement.textContent = originalText;
                    buttonElement.disabled = false;
                }
            }
        }

        // Histogram functions
        async function loadHistogram() {
            if (!currentCollectionId) return;
            
            const container = document.getElementById('histogram-container');
            container.innerHTML = '<div class="loading">Loading histogram...</div>';
            
            try {
                const response = await fetch(`/api/collections/${currentCollectionId}/score-distribution`);
                if (!response.ok) {
                    container.innerHTML = '<div class="loading">Error loading histogram</div>';
                    return;
                }
                
                const data = await response.json();
                renderHistogram(data.distribution);
            } catch (error) {
                console.error('Error loading histogram:', error);
                container.innerHTML = '<div class="loading">Error loading histogram</div>';
            }
        }

        function renderHistogram(distribution) {
            const container = document.getElementById('histogram-container');
            
            if (!distribution || distribution.length === 0) {
                container.innerHTML = '<div class="loading">No data available</div>';
                return;
            }
            
            // Find max count for scaling
            const maxCount = Math.max(...distribution.map(d => d.count));
            const maxHeight = 200; // pixels
            
            // Build histogram HTML
            let histogramHTML = '<div class="histogram">';
            
            distribution.forEach(item => {
                const height = maxCount > 0 ? (item.count / maxCount) * maxHeight : 0;
                const scoreLabel = item.score > 0 ? `+${item.score}` : `${item.score}`;
                
                histogramHTML += `
                    <div class="histogram-bar" 
                         data-score="${item.score}"
                         data-sub-scores='${JSON.stringify(item.sub_score_distribution)}'
                         style="height: ${height}px;"
                         title="Score ${scoreLabel}: ${item.count} item(s)">
                        <span class="histogram-bar-value">${item.count}</span>
                        <span class="histogram-bar-label">${scoreLabel}</span>
                    </div>
                `;
            });
            
            histogramHTML += '</div>';
            container.innerHTML = histogramHTML;
            
            // Add click handlers
            container.querySelectorAll('.histogram-bar').forEach(bar => {
                bar.addEventListener('click', function() {
                    const score = parseInt(this.getAttribute('data-score'));
                    const subScoresJson = this.getAttribute('data-sub-scores');
                    const subScoreDistribution = JSON.parse(subScoresJson);
                    showSubScoreHistogram(score, subScoreDistribution);
                });
            });
        }

        function showSubScoreHistogram(score, subScoreDistribution) {
            // Remove existing popup if any (properly clean up event listener)
            const existingPopup = document.getElementById('sub-score-popup');
            if (existingPopup) {
                closeSubScoreHistogram();
            }
            
            // Create popup element
            const popup = document.createElement('div');
            popup.id = 'sub-score-popup';
            popup.className = 'sub-score-popup';
            
            // Build sub-histogram HTML
            let subHistogramHTML = '<div class="sub-histogram">';
            
            if (!subScoreDistribution || subScoreDistribution.length === 0) {
                subHistogramHTML += '<div style="padding: 20px; text-align: center; color: #666;">No sub-score data available (all items have the same sub-score or no comparisons within this group)</div>';
            } else {
                // Find max count for scaling
                const maxCount = Math.max(...subScoreDistribution.map(d => d.count));
                const maxHeight = 120; // pixels
                
                subScoreDistribution.forEach(item => {
                    const height = maxCount > 0 ? (item.count / maxCount) * maxHeight : 0;
                    const subScoreLabel = item.sub_score > 0 ? `+${item.sub_score}` : `${item.sub_score}`;
                    
                    subHistogramHTML += `
                        <div class="sub-histogram-bar" style="height: ${height}px;" title="Sub-score ${subScoreLabel}: ${item.count} item(s)">
                            <span class="sub-histogram-bar-value">${item.count}</span>
                            <span class="sub-histogram-bar-label">${subScoreLabel}</span>
                        </div>
                    `;
                });
            }
            
            subHistogramHTML += '</div>';
            
            const scoreLabel = score > 0 ? `+${score}` : `${score}`;
            popup.innerHTML = `
                <button class="close-btn" onclick="closeSubScoreHistogram()">√ó</button>
                <h4>Sub-Score Distribution for Score ${scoreLabel}</h4>
                ${subHistogramHTML}
                <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd; font-size: 0.9em; color: #666;">
                    <p>This shows how items with score ${scoreLabel} are distributed by their sub-scores (comparisons within the tied group).</p>
                </div>
            `;
            
            // Position popup near the clicked bar (or center if we can't determine position)
            document.body.appendChild(popup);
            
            // Center the popup initially
            const rect = popup.getBoundingClientRect();
            popup.style.left = `${(window.innerWidth - rect.width) / 2}px`;
            popup.style.top = `${(window.innerHeight - rect.height) / 2}px`;
            
            // Try to position near mouse/click position if available
            if (window.lastHistogramClick) {
                const x = window.lastHistogramClick.x;
                const y = window.lastHistogramClick.y;
                popup.style.left = `${Math.max(10, Math.min(x - rect.width / 2, window.innerWidth - rect.width - 10))}px`;
                popup.style.top = `${Math.max(10, Math.min(y - rect.height / 2, window.innerHeight - rect.height - 10))}px`;
            }
            
            // Close on outside click
            setTimeout(() => {
                document.addEventListener('click', closeSubScoreHistogramOnOutsideClick, true);
            }, 0);
        }

        function closeSubScoreHistogram() {
            const popup = document.getElementById('sub-score-popup');
            if (popup) {
                popup.remove();
            }
            document.removeEventListener('click', closeSubScoreHistogramOnOutsideClick, true);
        }

        function closeSubScoreHistogramOnOutsideClick(event) {
            const popup = document.getElementById('sub-score-popup');
            if (popup && !popup.contains(event.target)) {
                // Check if click was on a histogram bar
                const histogramBar = event.target.closest('.histogram-bar');
                if (!histogramBar) {
                    closeSubScoreHistogram();
                }
            }
        }

        // Track histogram bar clicks for positioning
        document.addEventListener('click', (event) => {
            if (event.target.closest('.histogram-bar')) {
                window.lastHistogramClick = {
                    x: event.clientX,
                    y: event.clientY
                };
            }
        });
    </script>
</body>
</html>

