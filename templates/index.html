<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RanQR - Rank Collections by Pairwise Comparisons</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .section-title {
            font-size: 1.5em;
            margin-bottom: 15px;
            color: #667eea;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
        }

        input[type="text"], textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        textarea {
            min-height: 150px;
            resize: vertical;
            font-family: inherit;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 1em;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: #6c757d;
        }

        button.danger {
            background: #dc3545;
        }

        .matchup-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
            justify-content: center;
            min-height: 200px;
        }
        
        .matchup-items-row {
            display: flex;
            gap: 20px;
            align-items: center;
            justify-content: center;
            width: 100%;
        }
        
        @media (max-width: 800px) {
            .matchup-items-row {
                flex-direction: column;
            }
            .matchup-items-row .matchup-item {
                width: 100%;
            }
            .matchup-vs-btn {
                margin: 20px 0;
            }
        }

        .matchup-item {
            flex: 1;
            min-width: 250px;
            padding: 30px;
            border: 3px solid #ddd;
            border-radius: 12px;
            text-align: center;
            background: #f8f9fa;
            transition: border-color 0.3s ease;
        }

        .matchup-item.clickable-item {
            cursor: pointer;
            user-select: none;
        }

        .matchup-item.clickable-item:hover {
            border-color: #667eea;
        }

        .matchup-item.clickable-item.selected {
            border-color: #28a745;
            border-width: 4px;
            background: #f0fff4;
        }

        .item-interactive-elements {
            position: relative;
            z-index: 1;
        }

        .matchup-vs-btn {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
            background: white;
            border: 3px solid #667eea;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            padding: 0;
            margin: 0 20px;
        }

        .matchup-vs-btn:hover {
            background: #667eea;
            color: white;
            transform: scale(1.1);
        }

        .matchup-vs-btn.selected {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            border-color: #28a745;
            color: white;
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4);
        }

        .matchup-vs-btn.selected:hover {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            transform: scale(1.05);
        }

        .matchup-vs-btn:focus {
            outline: none;
        }

        .matchup-vs-btn:active {
            transform: scale(0.95);
        }

        .matchup-vs {
            font-size: 1.5em;
            font-weight: bold;
            color: #667eea;
        }

        .matchup-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
            width: 100%;
        }
        
        @media (max-width: 600px) {
            .matchup-buttons {
                flex-direction: column;
                align-items: stretch;
            }
            
            .matchup-buttons button {
                width: 100%;
            }
        }

        .matchup-buttons button {
            min-width: 120px;
        }

        .vote-select-btn {
            transition: all 0.2s;
        }

        .vote-select-btn.selected {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4);
        }

        .vote-select-btn.selected.secondary {
            background: #6c757d;
            box-shadow: 0 5px 15px rgba(108, 117, 125, 0.4);
        }

        .submit-vote-btn-inactive {
            background: #6c757d !important;
            color: white !important;
            cursor: not-allowed !important;
            opacity: 0.6;
        }

        #submit-vote-btn:not(.submit-vote-btn-inactive) {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            cursor: pointer;
        }

        #submit-vote-btn:not(.submit-vote-btn-inactive):hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        #submit-vote-btn.submitting {
            background: #6c757d !important;
            color: white !important;
            cursor: not-allowed !important;
            opacity: 0.8;
            position: relative;
        }

        #submit-vote-btn.submitting::after {
            content: '';
            display: inline-block;
            width: 16px;
            height: 16px;
            margin-left: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .collections-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
        }

        .collection-card {
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            background: #f8f9fa;
        }

        .collection-card h3 {
            margin-bottom: 10px;
            color: #667eea;
        }

        .collection-card .meta {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        .collection-card .actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .collection-card .actions button {
            flex: 1;
            padding: 8px;
            font-size: 0.9em;
        }

        .rankings-list {
            list-style: none;
        }

        .rankings-list li {
            padding: 12px;
            margin-bottom: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid #667eea;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .rankings-list li:nth-child(1) {
            border-left-color: #ffd700;
            background: linear-gradient(90deg, #fff9e6 0%, #fff 100%);
        }

        .rankings-list li:nth-child(2) {
            border-left-color: #c0c0c0;
            background: linear-gradient(90deg, #f5f5f5 0%, #fff 100%);
        }

        .rankings-list li:nth-child(3) {
            border-left-color: #cd7f32;
            background: linear-gradient(90deg, #f5e6d3 0%, #fff 100%);
        }

        .rank-number {
            font-weight: bold;
            color: #667eea;
            margin-right: 10px;
            min-width: 30px;
        }

        .item-name {
            flex: 1;
        }

        .item-points {
            font-weight: bold;
            color: #555;
        }

        .item-points.positive {
            color: #28a745;
        }

        .item-points.negative {
            color: #dc3545;
        }

        .hidden {
            display: none;
        }

        .view-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .view-controls button {
            flex: 1;
        }

        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .stat-card {
            flex: 1;
            min-width: 150px;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
            text-align: center;
        }

        .stat-card .value {
            font-size: 2em;
            font-weight: bold;
        }

        .stat-card .label {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .matchup-item {
            display: flex;
            flex-direction: column;
        }

        .matchup-item-content {
            flex: 1;
        }

        .video-container {
            width: 100%;
            max-width: 560px;
            margin: 15px auto;
            position: relative;
            padding-bottom: 56.25%; /* 16:9 aspect ratio */
            height: 0;
            overflow: hidden;
        }

        .video-container iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 8px;
        }

        .item-actions {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }

        .item-actions button {
            padding: 6px 12px;
            font-size: 0.85em;
        }

        .edit-form {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }

        .edit-form input {
            flex: 1;
            padding: 8px;
            font-size: 0.9em;
        }

        .add-items-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #ddd;
        }

        .media-link-display {
            font-size: 0.85em;
            color: #666;
            margin-top: 5px;
        }

        .media-link-display a {
            color: #667eea;
            text-decoration: none;
        }

        .media-link-display a:hover {
            text-decoration: underline;
        }

        .vote-item-card {
            padding: 12px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid #667eea;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .vote-item-card:hover {
            background: #e9ecef;
            transform: translateX(5px);
        }

        .vote-item-card.win {
            border-left-color: #28a745;
        }

        .vote-item-card.loss {
            border-left-color: #dc3545;
        }

        .vote-item-card.tie {
            border-left-color: #6c757d;
        }

        .vote-item-name {
            flex: 1;
            font-weight: 600;
        }

        .vote-item-action {
            color: #667eea;
            font-size: 0.9em;
            padding: 4px 8px;
            border-radius: 4px;
            background: white;
            cursor: pointer;
        }

        .vote-item-action:hover {
            background: #667eea;
            color: white;
        }

        /* Histogram Styles */
        .histogram {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            gap: 8px;
            padding: 20px;
            min-height: 200px;
            border-bottom: 2px solid #ddd;
            position: relative;
        }

        .histogram-bar {
            flex: 1;
            min-width: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 4px 4px 0 0;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
        }

        .histogram-bar:hover {
            opacity: 0.8;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.4);
        }

        .histogram-bar-label {
            position: absolute;
            bottom: -25px;
            font-size: 0.85em;
            color: #666;
            font-weight: 600;
            white-space: nowrap;
        }

        .histogram-bar-value {
            position: absolute;
            top: -25px;
            font-size: 0.9em;
            color: #667eea;
            font-weight: bold;
            background: white;
            padding: 2px 6px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            opacity: 1;
        }

        .histogram-bar.clicked {
            opacity: 0.7;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.6);
        }

        .histogram-axis {
            display: flex;
            justify-content: space-between;
            padding: 10px 20px;
            color: #666;
            font-size: 0.9em;
        }

        /* Nested Histogram Container */
        .histogram-row {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .histogram-row-header {
            margin-bottom: 10px;
            font-size: 0.9em;
            color: #666;
            font-weight: 600;
        }

        .histogram-row .histogram {
            min-height: 150px;
            padding: 15px;
        }

        .histogram-row .histogram-bar {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }

        .histogram-row.level-2 .histogram-bar {
            background: linear-gradient(135deg, #ffc107 0%, #ff9800 100%);
        }

        .histogram-row.level-3 .histogram-bar {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }

        .histogram-row.level-4 .histogram-bar {
            background: linear-gradient(135deg, #6f42c1 0%, #5a32a3 100%);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ RanQR - Rank Your Collections</h1>

        <div id="collections-view" class="card">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-wrap: wrap; gap: 15px;">
                <h2 class="section-title" style="margin: 0;">Your Collections</h2>
            </div>
            <div id="collections-list" class="collections-list"></div>
            
            <h3 class="section-title" style="margin-top: 30px;">Create New Collection</h3>
            <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                <button onclick="showCreateDialog()">‚ûï Create Collection</button>
                <button onclick="showImportDialog()">üì§ Import Collection</button>
            </div>
            
            <div id="create-collection-form" class="hidden">
                <div class="form-group">
                    <label for="collection-name">Collection Name:</label>
                    <input type="text" id="collection-name" placeholder="Enter collection name">
                </div>
                <div class="form-group">
                    <label for="search-prefix-input">YouTube Search Prefix (optional):</label>
                    <input type="text" id="search-prefix-input" placeholder="e.g., artist name, series name...">
                    <small style="color: #666; font-size: 0.9em;">This will be added to YouTube searches for items in this collection</small>
                </div>
                <div class="form-group">
                    <label for="items-input">Items (one per line):</label>
                    <textarea id="items-input" placeholder="Enter items, one per line..."></textarea>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button onclick="createCollection()">Create Collection</button>
                    <button class="secondary" onclick="hideCreateDialog()">Cancel</button>
                </div>
            </div>
        </div>

        <div id="collection-view" class="hidden">
            <div class="card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 class="section-title" style="margin: 0;" id="collection-title"></h2>
                    <button class="secondary" onclick="showCollections()">‚Üê Back to Collections</button>
                </div>
                
                <div class="view-controls">
                    <button onclick="showMatchup()">Make Comparisons</button>
                    <button onclick="showRankings()">View Rankings</button>
                    <button onclick="showFixedTriangles()">Resolve Triangles</button>
                    <button onclick="showControversialVotes()">Controversial Votes</button>
                </div>

                <div id="stats" class="stats hidden"></div>
            </div>

            <div id="matchup-section" class="card hidden">
                <h3 class="section-title" id="pairwise-comparison-header">Pairwise Comparison</h3>
                <div id="matchup-container" class="matchup-container">
                    <div class="loading">Loading next matchup...</div>
                </div>
                <div id="matchup-edit-section" class="hidden" style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #ddd;">
                    <h4 style="margin-bottom: 15px; color: #667eea;">Edit Items</h4>
                    <div id="matchup-edit-items" style="display: flex; flex-direction: column; gap: 15px;"></div>
                </div>
            </div>

            <div id="rankings-section" class="card hidden">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3 class="section-title" style="margin: 0;">Current Rankings</h3>
                    <button onclick="editCollectionSearchPrefix()" style="padding: 6px 12px; font-size: 0.9em;">‚öôÔ∏è Edit Search Prefix</button>
                </div>
                
                <div id="collection-search-prefix-display" style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 6px;">
                    <strong>YouTube Search Prefix:</strong> <span id="search-prefix-value">None</span>
                </div>
                
                <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                    <div style="position: relative;">
                        <button onclick="toggleExportMenu()">üì• Export Collection</button>
                        <div id="export-menu" class="hidden" style="position: absolute; top: 100%; left: 0; margin-top: 5px; background: white; border: 2px solid #667eea; border-radius: 6px; box-shadow: 0 5px 15px rgba(0,0,0,0.2); z-index: 100; min-width: 200px;">
                            <button onclick="exportCollectionToFile(event)" style="width: 100%; text-align: left; border: none; border-bottom: 1px solid #ddd; border-radius: 0; padding: 10px 15px; background: white; cursor: pointer;">üíæ Download as File</button>
                            <button onclick="exportCollectionToClipboard(event)" style="width: 100%; text-align: left; border: none; border-radius: 0; padding: 10px 15px; background: white; cursor: pointer;">üìã Copy to Clipboard</button>
                        </div>
                    </div>
                </div>
                
                <div id="histogram-section" style="margin-bottom: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px;">
                    <h4 style="margin-bottom: 15px; color: #667eea;">Score Distribution</h4>
                    <div id="histogram-container" style="min-height: 200px; position: relative;">
                        <div class="loading">Loading histogram...</div>
                    </div>
                </div>

                <div class="add-items-section">
                    <h4 style="margin-bottom: 10px; color: #667eea;">Add New Items</h4>
                    <div class="form-group">
                        <label for="new-items-input">Items (one per line):</label>
                        <textarea id="new-items-input" placeholder="Enter new items, one per line..."></textarea>
                    </div>
                    <button onclick="addItemsToCollection()">Add Items</button>
                </div>

                <ul id="rankings-list" class="rankings-list"></ul>
            </div>

            <div id="fixed-triangles-section" class="card hidden">
                <h3 class="section-title">Resolve Triangles</h3>
                <div id="triangles-container">
                    <div class="loading">Loading triangles...</div>
                </div>
            </div>

            <div id="controversial-votes-section" class="card hidden">
                <h3 class="section-title">Controversial Votes</h3>
                <div id="controversial-votes-container">
                    <div class="loading">Loading controversial votes...</div>
                </div>
            </div>
        </div>
        
        <!-- Import Dialog - Outside both views so it's always accessible -->
        <div id="import-dialog" class="hidden" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
            <div class="card" style="max-width: 600px; max-height: 80vh; overflow-y: auto;">
                <h3 class="section-title">Import Collection</h3>
                <div class="form-group">
                    <label for="import-json-input">Paste JSON data:</label>
                    <textarea id="import-json-input" style="min-height: 300px; font-family: monospace;" placeholder='{"version":"1.0","collection":{"name":"..."},"items":[...],"comparisons":[...]}'></textarea>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button onclick="importCollection()">Import</button>
                    <button class="secondary" onclick="hideImportDialog()">Cancel</button>
                </div>
            </div>
        </div>
        
        <!-- Voting History Dialog -->
        <div id="votes-dialog" class="hidden" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
            <div class="card" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3 class="section-title" style="margin: 0;" id="votes-item-name"></h3>
                    <button class="secondary" onclick="hideVotesDialog()">‚úï Close</button>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                        <div class="stat-card" style="min-width: 120px;">
                            <div class="value" id="votes-wins-count">0</div>
                            <div class="label">Wins</div>
                        </div>
                        <div class="stat-card" style="min-width: 120px;">
                            <div class="value" id="votes-losses-count">0</div>
                            <div class="label">Losses</div>
                        </div>
                        <div class="stat-card" style="min-width: 120px;">
                            <div class="value" id="votes-ties-count">0</div>
                            <div class="label">Ties</div>
                        </div>
                        <div class="stat-card" style="min-width: 120px;">
                            <div class="value" id="votes-points">0</div>
                            <div class="label">Points</div>
                        </div>
                    </div>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <button class="danger" onclick="resetItemVotes()" id="reset-votes-btn">üîÑ Reset All Votes</button>
                </div>
                
                <div id="votes-wins-section" style="margin-bottom: 20px;">
                    <h4 style="color: #28a745; margin-bottom: 10px;">‚úì Won Against</h4>
                    <div id="votes-wins-list" style="display: flex; flex-direction: column; gap: 8px;"></div>
                </div>
                
                <div id="votes-losses-section" style="margin-bottom: 20px;">
                    <h4 style="color: #dc3545; margin-bottom: 10px;">‚úó Lost Against</h4>
                    <div id="votes-losses-list" style="display: flex; flex-direction: column; gap: 8px;"></div>
                </div>
                
                <div id="votes-ties-section">
                    <h4 style="color: #6c757d; margin-bottom: 10px;">= Tied With</h4>
                    <div id="votes-ties-list" style="display: flex; flex-direction: column; gap: 8px;"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentCollectionId = null;
        let currentCollection = null;
        // Track selected histogram score paths for filtering rankings
        let selectedScorePaths = new Set();
        // Flag to prevent infinite loops when reloading rankings
        let isLoadingRankings = false;

        // Initialize
        window.onload = () => {
            loadCollections();
        };

        async function loadCollections() {
            try {
                const response = await fetch('/api/collections');
                const collections = await response.json();
                
                const listEl = document.getElementById('collections-list');
                listEl.innerHTML = '';
                
                if (collections.length === 0) {
                    listEl.innerHTML = '<p style="text-align: center; color: #666;">No collections yet. Create one above!</p>';
                    return;
                }
                
                collections.forEach(collection => {
                    const card = document.createElement('div');
                    card.className = 'collection-card';
                    card.innerHTML = `
                        <h3>${escapeHtml(collection.name)}</h3>
                        <div class="meta">${collection.item_count} items</div>
                        <div class="actions">
                            <button onclick="openCollection(${collection.id})">Open</button>
                            <button class="danger" onclick="deleteCollection(${collection.id})">Delete</button>
                        </div>
                    `;
                    listEl.appendChild(card);
                });
            } catch (error) {
                console.error('Error loading collections:', error);
                alert('Error loading collections');
            }
        }

        function getYouTubeSearchUrl(searchPrefix, itemName) {
            // Combine search prefix and item name, properly URL-encoded
            const query = searchPrefix ? `${searchPrefix} ${itemName}` : itemName;
            return `https://www.youtube.com/results?search_query=${encodeURIComponent(query)}`;
        }

        async function createCollection() {
            const name = document.getElementById('collection-name').value.trim();
            const searchPrefix = document.getElementById('search-prefix-input').value.trim();
            const items = document.getElementById('items-input').value.trim();
            
            if (!name) {
                alert('Please enter a collection name');
                return;
            }
            
            if (!items) {
                alert('Please enter at least one item');
                return;
            }
            
            try {
                const response = await fetch('/api/collections', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        name,
                        search_prefix: searchPrefix || null,
                        items
                    })
                });
                
                if (response.ok) {
                    hideCreateDialog();
                    loadCollections();
                    const data = await response.json();
                    openCollection(data.id);
                } else {
                    alert('Error creating collection');
                }
            } catch (error) {
                console.error('Error creating collection:', error);
                alert('Error creating collection');
            }
        }

        async function openCollection(id) {
            currentCollectionId = id;
            // Clear histogram selections when switching collections
            selectedScorePaths.clear();
            try {
                const response = await fetch(`/api/collections/${id}`);
                currentCollection = await response.json();
                
                document.getElementById('collections-view').classList.add('hidden');
                document.getElementById('collection-view').classList.remove('hidden');
                document.getElementById('collection-title').textContent = currentCollection.name;
                
                // Update search prefix display
                const prefixDisplay = document.getElementById('search-prefix-value');
                if (prefixDisplay) {
                    prefixDisplay.textContent = currentCollection.search_prefix || 'None';
                }
                
                showRankings();
            } catch (error) {
                console.error('Error opening collection:', error);
                alert('Error opening collection');
            }
        }

        function showCollections() {
            document.getElementById('collections-view').classList.remove('hidden');
            document.getElementById('collection-view').classList.add('hidden');
            currentCollectionId = null;
            currentCollection = null;
            loadCollections();
        }

        async function showMatchup() {
            document.getElementById('matchup-section').classList.remove('hidden');
            document.getElementById('rankings-section').classList.add('hidden');
            document.getElementById('fixed-triangles-section').classList.add('hidden');
            document.getElementById('controversial-votes-section').classList.add('hidden');
            await loadNextMatchup();
        }

        async function showRankings() {
            document.getElementById('matchup-section').classList.add('hidden');
            document.getElementById('rankings-section').classList.remove('hidden');
            document.getElementById('fixed-triangles-section').classList.add('hidden');
            document.getElementById('controversial-votes-section').classList.add('hidden');
            await loadRankings();
        }

        async function showFixedTriangles() {
            document.getElementById('matchup-section').classList.add('hidden');
            document.getElementById('rankings-section').classList.add('hidden');
            document.getElementById('fixed-triangles-section').classList.remove('hidden');
            document.getElementById('controversial-votes-section').classList.add('hidden');
            await loadTriangles();
        }

        async function showControversialVotes() {
            document.getElementById('matchup-section').classList.add('hidden');
            document.getElementById('rankings-section').classList.add('hidden');
            document.getElementById('fixed-triangles-section').classList.add('hidden');
            document.getElementById('controversial-votes-section').classList.remove('hidden');
            await loadControversialVotes();
        }

        async function loadTriangles() {
            const container = document.getElementById('triangles-container');
            container.innerHTML = '<div class="loading">Loading triangles...</div>';
            
            try {
                const response = await fetch(`/api/collections/${currentCollectionId}/triangles`);
                if (!response.ok) {
                    container.innerHTML = '<div class="loading">Error loading triangles</div>';
                    return;
                }
                
                const data = await response.json();
                
                if (!data.triangles || data.triangles.length === 0) {
                    container.innerHTML = '<div class="loading" style="padding: 40px; text-align: center; color: #666;">No triangles (cycles) found in this collection. All comparisons are consistent!</div>';
                    return;
                }
                
                let html = '<div style="display: flex; flex-direction: column; gap: 20px;">';
                
                for (const triangle of data.triangles) {
                    html += `
                        <div style="border: 2px solid #667eea; border-radius: 8px; padding: 20px; background: #f8f9fa;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                <h4 style="margin: 0; color: #667eea;">Triangle (Dissonance: ${triangle.dissonance.toFixed(2)})</h4>
                                <button onclick="showTriangleOptions(${triangle.item_a.id}, ${triangle.item_b.id}, ${triangle.item_c.id})" 
                                        style="padding: 8px 16px; font-size: 0.9em;">Resolve</button>
                            </div>
                            <div style="display: flex; flex-direction: column; gap: 10px;">
                                <div><strong>${escapeHtml(triangle.item_a.name)}</strong> (${triangle.item_a.points > 0 ? '+' : ''}${triangle.item_a.points} pts)</div>
                                <div><strong>${escapeHtml(triangle.item_b.name)}</strong> (${triangle.item_b.points > 0 ? '+' : ''}${triangle.item_b.points} pts)</div>
                                <div><strong>${escapeHtml(triangle.item_c.name)}</strong> (${triangle.item_c.points > 0 ? '+' : ''}${triangle.item_c.points} pts)</div>
                            </div>
                        </div>
                    `;
                }
                
                html += '</div>';
                container.innerHTML = html;
            } catch (error) {
                console.error('Error loading triangles:', error);
                container.innerHTML = '<div class="loading">Error loading triangles</div>';
            }
        }

        async function showTriangleOptions(item_a_id, item_b_id, item_c_id) {
            try {
                const response = await fetch(`/api/collections/${currentCollectionId}/triangles/${item_a_id}/${item_b_id}/${item_c_id}/options`);
                if (!response.ok) {
                    alert('Error loading resolution options');
                    return;
                }
                
                const data = await response.json();
                
                // Get item names
                const collectionResponse = await fetch(`/api/collections/${currentCollectionId}`);
                const collection = await collectionResponse.json();
                const items_dict = {};
                collection.items.forEach(item => {
                    items_dict[item.id] = item;
                });
                
                const item_a_name = items_dict[item_a_id]?.name || 'Item A';
                const item_b_name = items_dict[item_b_id]?.name || 'Item B';
                const item_c_name = items_dict[item_c_id]?.name || 'Item C';
                
                // Create dialog
                let dialogHTML = `
                    <div id="triangle-options-dialog" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 2000; display: flex; align-items: center; justify-content: center; overflow-y: auto;">
                        <div class="card" style="max-width: 800px; max-height: 90vh; overflow-y: auto; margin: 20px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                                <h3 class="section-title" style="margin: 0;">Resolution Options</h3>
                                <button onclick="closeTriangleOptionsDialog()" style="background: none; border: none; font-size: 1.5em; cursor: pointer; color: #666;">√ó</button>
                            </div>
                            <div style="margin-bottom: 15px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                                <strong>Triangle:</strong> ${escapeHtml(item_a_name)}, ${escapeHtml(item_b_name)}, ${escapeHtml(item_c_name)}
                            </div>
                            <div id="triangle-options-list" style="display: flex; flex-direction: column; gap: 15px;">
                `;
                
                for (let i = 0; i < data.options.length; i++) {
                    const option = data.options[i];
                    const ordering = option.ordering;
                    const firstItem = items_dict[ordering[0].item_id];
                    const secondItem = items_dict[ordering[1].item_id];
                    const thirdItem = items_dict[ordering[2].item_id];
                    
                    const dissonanceChange = option.dissonance_change;
                    const changeColor = dissonanceChange < 0 ? '#28a745' : dissonanceChange > 0 ? '#dc3545' : '#6c757d';
                    const changeSymbol = dissonanceChange < 0 ? '‚Üì' : dissonanceChange > 0 ? '‚Üë' : '=';
                    
                    dialogHTML += `
                        <div style="border: 2px solid #ddd; border-radius: 6px; padding: 15px; background: white;">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                                <div>
                                    <strong>Option ${i + 1}:</strong>
                                    <div style="margin-top: 5px; color: #666;">
                                        1st: ${escapeHtml(firstItem.name)}<br>
                                        2nd: ${escapeHtml(secondItem.name)}<br>
                                        3rd: ${escapeHtml(thirdItem.name)}
                                    </div>
                                </div>
                                <div style="text-align: right;">
                                    <div style="color: ${changeColor}; font-weight: bold; font-size: 1.1em;">
                                        ${changeSymbol} ${Math.abs(dissonanceChange).toFixed(2)}
                                    </div>
                                    <div style="font-size: 0.85em; color: #666;">
                                        Dissonance change
                                    </div>
                                </div>
                            </div>
                            <button onclick="resolveTriangle(${item_a_id}, ${item_b_id}, ${item_c_id}, ${i})" 
                                    style="width: 100%; padding: 10px; font-size: 0.95em; ${dissonanceChange < 0 ? 'background: #28a745;' : ''}">
                                Select This Resolution
                            </button>
                        </div>
                    `;
                }
                
                dialogHTML += `
                            </div>
                        </div>
                    </div>
                `;
                
                // Remove existing dialog if any
                const existing = document.getElementById('triangle-options-dialog');
                if (existing) {
                    existing.remove();
                }
                
                document.body.insertAdjacentHTML('beforeend', dialogHTML);
                
                // Store options data for resolution
                window.currentTriangleOptions = {
                    item_a_id: item_a_id,
                    item_b_id: item_b_id,
                    item_c_id: item_c_id,
                    options: data.options
                };
            } catch (error) {
                console.error('Error loading triangle options:', error);
                alert('Error loading resolution options');
            }
        }

        function closeTriangleOptionsDialog() {
            const dialog = document.getElementById('triangle-options-dialog');
            if (dialog) {
                dialog.remove();
            }
            window.currentTriangleOptions = null;
        }

        async function resolveTriangle(item_a_id, item_b_id, item_c_id, optionIndex) {
            if (!window.currentTriangleOptions) {
                alert('Error: Triangle options not loaded');
                return;
            }
            
            const option = window.currentTriangleOptions.options[optionIndex];
            const resolution = option.resolution;
            
            try {
                const response = await fetch(`/api/collections/${currentCollectionId}/triangles/resolve`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        item_a_id: item_a_id,
                        item_b_id: item_b_id,
                        item_c_id: item_c_id,
                        resolution: resolution
                    })
                });
                
                if (response.ok) {
                    closeTriangleOptionsDialog();
                    await loadTriangles(); // Reload triangles list
                    await loadRankings(); // Update rankings
                    alert('Triangle resolved successfully!');
                } else {
                    const error = await response.json();
                    alert(`Error resolving triangle: ${error.error || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Error resolving triangle:', error);
                alert('Error resolving triangle');
            }
        }

        async function loadControversialVotes() {
            const container = document.getElementById('controversial-votes-container');
            container.innerHTML = '<div class="loading">Loading controversial votes...</div>';
            
            try {
                const response = await fetch(`/api/collections/${currentCollectionId}/controversial-votes`);
                if (!response.ok) {
                    container.innerHTML = '<div class="loading">Error loading controversial votes</div>';
                    return;
                }
                
                const data = await response.json();
                
                let html = '';
                
                // Display total controversy score
                html += `
                    <div style="margin-bottom: 30px; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 8px;">
                        <div style="font-size: 1.2em; margin-bottom: 10px; font-weight: bold;">Total Controversy Score</div>
                        <div style="font-size: 2.5em; font-weight: bold;">${data.total_controversy.toFixed(2)}</div>
                        <div style="font-size: 0.9em; opacity: 0.9; margin-top: 5px;">
                            ${data.total_controversial_count} controversial vote${data.total_controversial_count !== 1 ? 's' : ''} found
                        </div>
                    </div>
                `;
                
                if (!data.controversial_votes || data.controversial_votes.length === 0) {
                    html += '<div class="loading" style="padding: 40px; text-align: center; color: #666;">There are no controversial votes. All votes are consistent with the current scores!</div>';
                    container.innerHTML = html;
                    return;
                }
                
                html += '<div style="display: flex; flex-direction: column; gap: 20px;">';
                
                for (const vote of data.controversial_votes) {
                    const item1 = vote.item1;
                    const item2 = vote.item2;
                    const score1 = item1.points;
                    const score2 = item2.points;
                    const scoreDiff = vote.score_difference;
                    const controversyScore = vote.controversy_score;
                    const swapImpact = vote.swap_impact !== undefined ? vote.swap_impact : 0;
                    
                    // Determine which item has higher score
                    const higherItem = score1 > score2 ? item1 : item2;
                    const lowerItem = score1 > score2 ? item2 : item1;
                    const higherScore = Math.max(score1, score2);
                    const lowerScore = Math.min(score1, score2);
                    
                    // Format swap impact
                    const swapImpactFormatted = swapImpact.toFixed(2);
                    const swapImpactColor = swapImpact < 0 ? '#28a745' : swapImpact > 0 ? '#dc3545' : '#666';
                    const swapImpactText = swapImpact < 0 
                        ? `Reduces controversy by ${Math.abs(swapImpact).toFixed(2)}`
                        : swapImpact > 0 
                        ? `Increases controversy by ${swapImpactFormatted}`
                        : 'No change in controversy';
                    
                    html += `
                        <div style="border: 2px solid #dc3545; border-radius: 8px; padding: 20px; background: #fff5f5;">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 15px; flex-wrap: wrap; gap: 15px;">
                                <div style="flex: 1; min-width: 300px;">
                                    <div style="font-size: 1.1em; font-weight: bold; color: #dc3545; margin-bottom: 10px;">
                                        Controversy Score: ${controversyScore.toFixed(2)}
                                    </div>
                                    <div style="margin-bottom: 8px;">
                                        <strong>Vote:</strong> ${escapeHtml(vote.vote_description)}
                                    </div>
                                    <div style="display: flex; flex-direction: column; gap: 8px; margin-top: 10px;">
                                        <div>
                                            <strong>${escapeHtml(item1.name)}</strong>: ${score1 > 0 ? '+' : ''}${score1} points
                                        </div>
                                        <div>
                                            <strong>${escapeHtml(item2.name)}</strong>: ${score2 > 0 ? '+' : ''}${score2} points
                                        </div>
                                        <div style="color: #dc3545; font-weight: bold;">
                                            Score Difference: ${scoreDiff} (${escapeHtml(higherItem.name)} has higher score)
                                        </div>
                                        <div style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 4px; border-left: 4px solid ${swapImpactColor};">
                                            <div style="font-weight: bold; color: ${swapImpactColor}; margin-bottom: 4px;">
                                                Swap Impact: ${swapImpactFormatted}
                                            </div>
                                            <div style="font-size: 0.9em; color: #666;">
                                                ${swapImpactText}
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div style="display: flex; align-items: center;">
                                    <button onclick="swapControversialVote(${vote.comparison_id}, ${item1.id}, ${item2.id}, '${vote.vote_result}')" 
                                            style="padding: 10px 20px; font-size: 0.95em; background: #ffc107; color: #000;">
                                        üîÑ Swap Vote
                                    </button>
                                </div>
                            </div>
                        </div>
                    `;
                }
                
                html += '</div>';
                container.innerHTML = html;
            } catch (error) {
                console.error('Error loading controversial votes:', error);
                container.innerHTML = '<div class="loading">Error loading controversial votes</div>';
            }
        }

        async function swapControversialVote(comparisonId, item1Id, item2Id, currentResult) {
            // Get collection data once
            let collection, items_dict, item1, item2;
            try {
                const collectionResponse = await fetch(`/api/collections/${currentCollectionId}`);
                collection = await collectionResponse.json();
                items_dict = {};
                collection.items.forEach(item => {
                    items_dict[item.id] = item;
                });
                
                item1 = items_dict[item1Id];
                item2 = items_dict[item2Id];
                
                if (!item1 || !item2) {
                    alert('Error: Items not found');
                    return;
                }
            } catch (error) {
                console.error('Error fetching collection:', error);
                alert('Error loading collection data');
                return;
            }
            
            // Determine the new result (swap the vote)
            let newResult;
            if (currentResult === 'item1') {
                newResult = 'item2';
            } else if (currentResult === 'item2') {
                newResult = 'item1';
            } else {
                // For ties, determine which item should win based on scores
                // If scores are equal, default to item1
                if (item1.points >= item2.points) {
                    newResult = 'item1';
                } else {
                    newResult = 'item2';
                }
            }
            
            let currentVoteDesc;
            if (currentResult === 'item1') {
                currentVoteDesc = `"${item1.name}" > "${item2.name}"`;
            } else if (currentResult === 'item2') {
                currentVoteDesc = `"${item2.name}" > "${item1.name}"`;
            } else {
                currentVoteDesc = `"${item1.name}" = "${item2.name}"`;
            }
            
            let newVoteDesc;
            if (newResult === 'item1') {
                newVoteDesc = `"${item1.name}" > "${item2.name}"`;
            } else if (newResult === 'item2') {
                newVoteDesc = `"${item2.name}" > "${item1.name}"`;
            } else {
                newVoteDesc = `"${item1.name}" = "${item2.name}"`;
            }
            
            const confirmMessage = `Swap this vote?\n\nCurrent: ${currentVoteDesc}\nNew: ${newVoteDesc}\n\nClick OK to swap, or Cancel to keep current vote.`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Ensure consistent ordering (smaller ID first)
            const item1_id = Math.min(item1Id, item2Id);
            const item2_id = Math.max(item1Id, item2Id);
            
            // Adjust result if IDs were swapped
            let adjustedResult = newResult;
            if (item1Id > item2Id) {
                if (newResult === 'item1') {
                    adjustedResult = 'item2';
                } else if (newResult === 'item2') {
                    adjustedResult = 'item1';
                }
            }
            
            try {
                const response = await fetch(`/api/collections/${currentCollectionId}/matchup`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        item1_id: item1_id,
                        item2_id: item2_id,
                        winner: adjustedResult
                    })
                });
                
                if (response.ok) {
                    // Reload controversial votes and rankings
                    await loadControversialVotes();
                    await loadRankings();
                } else {
                    const error = await response.json();
                    alert(`Error swapping vote: ${error.error || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Error swapping vote:', error);
                alert('Error swapping vote');
            }
        }

        async function loadNextMatchup(specificItem1Id = null, specificItem2Id = null) {
            const container = document.getElementById('matchup-container');
            container.innerHTML = '<div class="loading">Loading next matchup...</div>';
            
            try {
                let url = `/api/collections/${currentCollectionId}/matchup`;
                // If specific items requested, add them as query parameters
                if (specificItem1Id && specificItem2Id) {
                    url += `?item1_id=${specificItem1Id}&item2_id=${specificItem2Id}`;
                }
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.message) {
                    container.innerHTML = `<div class="loading">${data.message}</div>`;
                    return;
                }
                
                // Build video embeds if media links exist
                const video1 = data.item1.media_link ? getYouTubeEmbed(data.item1.media_link) : '';
                const video2 = data.item2.media_link ? getYouTubeEmbed(data.item2.media_link) : '';
                
                // Get search prefix for YouTube search links
                const searchPrefix = currentCollection ? (currentCollection.search_prefix || '') : '';
                const searchUrl1 = getYouTubeSearchUrl(searchPrefix, data.item1.name);
                const searchUrl2 = getYouTubeSearchUrl(searchPrefix, data.item2.name);
                
                container.innerHTML = `
                    <div class="matchup-items-row">
                        <div class="matchup-item clickable-item" id="item1-container" data-item="item1">
                            <div class="matchup-item-content" style="display: flex; flex-direction: column; gap: 15px;">
                                <div class="item-interactive-elements" style="display: flex; justify-content: center; gap: 5px; flex-wrap: wrap;">
                                    <a href="${escapeHtml(searchUrl1)}" target="_blank" style="padding: 4px 8px; font-size: 0.8em; background: #dc3545; color: white; text-decoration: none; border-radius: 4px;">üîç Search</a>
                                    <button onclick="autoFillYouTube(${data.item1.id}, event)" style="padding: 4px 8px; font-size: 0.8em; background: #28a745; color: white;">ü§ñ Auto YT</button>
                                    <button onclick="toggleEditItem(${data.item1.id}, event)" style="padding: 4px 8px; font-size: 0.8em;">‚úèÔ∏è Edit</button>
                                </div>
                                <div style="font-size: 1.2em; font-weight: bold; text-align: center;">${escapeHtml(data.item1.name)}</div>
                                <div id="item1-score-container" style="min-height: 20px; text-align: center; color: #666; font-size: 0.95em;"></div>
                                ${video1 ? `<div class="item-interactive-elements">${video1}</div>` : ''}
                            </div>
                        </div>
                        <button class="matchup-vs-btn" id="tie-button" onclick="selectVote('tie')">?</button>
                        <div class="matchup-item clickable-item" id="item2-container" data-item="item2">
                            <div class="matchup-item-content" style="display: flex; flex-direction: column; gap: 15px;">
                                <div class="item-interactive-elements" style="display: flex; justify-content: center; gap: 5px; flex-wrap: wrap;">
                                    <a href="${escapeHtml(searchUrl2)}" target="_blank" style="padding: 4px 8px; font-size: 0.8em; background: #dc3545; color: white; text-decoration: none; border-radius: 4px;">üîç Search</a>
                                    <button onclick="autoFillYouTube(${data.item2.id}, event)" style="padding: 4px 8px; font-size: 0.8em; background: #28a745; color: white;">ü§ñ Auto YT</button>
                                    <button onclick="toggleEditItem(${data.item2.id}, event)" style="padding: 4px 8px; font-size: 0.8em;">‚úèÔ∏è Edit</button>
                                </div>
                                <div style="font-size: 1.2em; font-weight: bold; text-align: center;">${escapeHtml(data.item2.name)}</div>
                                <div id="item2-score-container" style="min-height: 20px; text-align: center; color: #666; font-size: 0.95em;"></div>
                                ${video2 ? `<div class="item-interactive-elements">${video2}</div>` : ''}
                            </div>
                        </div>
                    </div>
                    <div id="submit-vote-section" style="margin-top: 20px; text-align: center;">
                        <button onclick="submitSelectedVote()" id="submit-vote-btn" disabled class="submit-vote-btn-inactive" style="padding: 12px 32px; font-size: 1.1em;">Submit</button>
                    </div>
                    <div style="width: 100%; margin-top: 30px; padding-top: 20px; border-top: 2px solid #ddd; text-align: center;">
                        <button onclick="revealScores()" style="padding: 10px 20px; font-size: 0.95em; background: #6c757d; color: white;">üìä Reveal Scores</button>
                        ${window.lastVote ? `
                        <button onclick="changeLastVote()" style="padding: 10px 20px; font-size: 0.95em; background: #ffc107; color: #000; margin-left: 10px;">‚Ü©Ô∏è Revise Last Vote</button>
                        ` : ''}
                    </div>
                `;
                
                // Set up edit section for both items
                setupMatchupEditSection(data.item1, data.item2);
                
                // Pre-fetch scores for the two items
                let item1ScoreData = null;
                let item2ScoreData = null;
                try {
                    const collectionResponse = await fetch(`/api/collections/${currentCollectionId}`);
                    const collection = await collectionResponse.json();
                    
                    item1ScoreData = collection.items.find(i => i.id === data.item1.id);
                    item2ScoreData = collection.items.find(i => i.id === data.item2.id);
                } catch (error) {
                    console.error('Error pre-fetching scores:', error);
                    // Continue without scores - revealScores will fetch them if needed
                }
                
                window.currentMatchup = {
                    item1_id: data.item1.id,
                    item2_id: data.item2.id,
                    item1_name: data.item1.name,
                    item2_name: data.item2.name,
                    item1_media_link: data.item1.media_link,
                    item2_media_link: data.item2.media_link,
                    item1_score_data: item1ScoreData,
                    item2_score_data: item2ScoreData
                };
                
                // Clear score containers initially
                const score1Container = document.getElementById('item1-score-container');
                const score2Container = document.getElementById('item2-score-container');
                if (score1Container) score1Container.innerHTML = '';
                if (score2Container) score2Container.innerHTML = '';
                
                // Clear selected vote when loading new matchup
                selectedVote = null;
                
                // Set up container click handlers
                const item1Container = document.getElementById('item1-container');
                const item2Container = document.getElementById('item2-container');
                
                if (item1Container) {
                    item1Container.addEventListener('click', function(e) {
                        // Don't trigger if clicking on interactive elements or their children
                        if (e.target.closest('.item-interactive-elements') || 
                            e.target.tagName === 'A' || 
                            e.target.tagName === 'BUTTON' ||
                            e.target.closest('iframe')) {
                            return;
                        }
                        e.stopPropagation();
                        selectVote('item1');
                    });
                }
                
                if (item2Container) {
                    item2Container.addEventListener('click', function(e) {
                        // Don't trigger if clicking on interactive elements or their children
                        if (e.target.closest('.item-interactive-elements') || 
                            e.target.tagName === 'A' || 
                            e.target.tagName === 'BUTTON' ||
                            e.target.closest('iframe')) {
                            return;
                        }
                        e.stopPropagation();
                        selectVote('item2');
                    });
                }
                
                // Clear selected vote when loading new matchup
                selectedVote = null;
                
                // Clear any submitting state from submit button
                const submitBtn = document.getElementById('submit-vote-btn');
                if (submitBtn) {
                    submitBtn.classList.remove('submitting');
                }
                
                // Update center button and submit button state
                updateVoteButtonStates();
                
                // Scroll to comparison container if we're loading after a previous vote
                if (window.lastVote) {
                    // Use setTimeout to ensure DOM is fully rendered before scrolling
                    setTimeout(() => {
                        const matchupSection = document.getElementById('matchup-section');
                        const header = document.getElementById('pairwise-comparison-header');
                        
                        if (matchupSection && header) {
                            const viewportHeight = window.innerHeight;
                            const sectionRect = matchupSection.getBoundingClientRect();
                            const sectionHeight = sectionRect.height;
                            
                            if (sectionHeight < viewportHeight) {
                                // Container is smaller than viewport: scroll so bottom of container is at bottom of viewport
                                const sectionBottomAbsolute = sectionRect.bottom + window.scrollY;
                                const targetScrollPosition = sectionBottomAbsolute - viewportHeight;
                                window.scrollTo({
                                    top: targetScrollPosition,
                                    behavior: 'smooth'
                                });
                            } else {
                                // Container is larger than viewport: scroll so top of container (header) is at top of viewport
                                header.scrollIntoView({
                                    behavior: 'smooth',
                                    block: 'start'
                                });
                            }
                        }
                    }, 100);
                }
                
                // Keep last vote info - don't clear it, just update it when we vote
            } catch (error) {
                console.error('Error loading matchup:', error);
                container.innerHTML = '<div class="loading">Error loading matchup</div>';
            }
        }


        let selectedVote = null;

        function updateVoteButtonStates() {
            const tieButton = document.getElementById('tie-button');
            const item1Container = document.getElementById('item1-container');
            const item2Container = document.getElementById('item2-container');
            const submitBtn = document.getElementById('submit-vote-btn');
            
            // Update center button symbol
            if (tieButton) {
                if (selectedVote === null) {
                    tieButton.textContent = '?';
                    tieButton.classList.remove('selected');
                } else if (selectedVote === 'tie') {
                    tieButton.textContent = '=';
                    tieButton.classList.add('selected');
                } else if (selectedVote === 'item1') {
                    tieButton.textContent = '>';
                    tieButton.classList.remove('selected');
                } else if (selectedVote === 'item2') {
                    tieButton.textContent = '<';
                    tieButton.classList.remove('selected');
                }
                // Remove focus to prevent weird color changes when clicking elsewhere
                if (document.activeElement === tieButton) {
                    tieButton.blur();
                }
            }
            
            // Update container selection states
            if (item1Container) {
                if (selectedVote === 'item1') {
                    item1Container.classList.add('selected');
                } else {
                    item1Container.classList.remove('selected');
                }
            }
            
            if (item2Container) {
                if (selectedVote === 'item2') {
                    item2Container.classList.add('selected');
                } else {
                    item2Container.classList.remove('selected');
                }
            }
            
            // Update submit button state
            if (submitBtn) {
                // Don't change button state if it's currently submitting
                if (!submitBtn.classList.contains('submitting')) {
                    if (selectedVote === null) {
                        submitBtn.disabled = true;
                        submitBtn.classList.add('submit-vote-btn-inactive');
                    } else {
                        submitBtn.disabled = false;
                        submitBtn.classList.remove('submit-vote-btn-inactive');
                    }
                }
            }
        }

        function selectVote(winner) {
            // Toggle selection: if clicking the same option that's already selected, deselect it
            if (selectedVote === winner) {
                // Deselect: remove selection
                selectedVote = null;
            } else {
                // Select: set new selection
                selectedVote = winner;
            }
            
            // Update all button and container states
            updateVoteButtonStates();
        }

        async function submitSelectedVote() {
            if (!selectedVote || !window.currentMatchup) {
                alert('Please select a vote option first');
                return;
            }
            
            // Store pre-submit state for potential revert
            const preSubmitState = {
                selectedVote: selectedVote,
                currentMatchup: {...window.currentMatchup}
            };
            
            // Disable submit button and show spinner
            const submitBtn = document.getElementById('submit-vote-btn');
            if (submitBtn) {
                submitBtn.disabled = true;
                submitBtn.classList.add('submitting');
                submitBtn.classList.remove('submit-vote-btn-inactive');
            }
            
            try {
                await submitMatchup(selectedVote);
                // On success, loadNextMatchup will clear the state, so we don't need to do anything here
            } catch (error) {
                // Revert to pre-submit state on failure
                selectedVote = preSubmitState.selectedVote;
                window.currentMatchup = preSubmitState.currentMatchup;
                updateVoteButtonStates();
                
                // Remove submitting state from button
                if (submitBtn) {
                    submitBtn.classList.remove('submitting');
                    if (selectedVote === null) {
                        submitBtn.disabled = true;
                        submitBtn.classList.add('submit-vote-btn-inactive');
                    } else {
                        submitBtn.disabled = false;
                    }
                }
            }
        }

        async function submitMatchup(winner) {
            if (!window.currentMatchup) return;
            
            const result = winner === 'item1' ? 'item1' : winner === 'item2' ? 'item2' : 'tie';
            
            // Store last vote info for quick change option
            window.lastVote = {
                item1_id: window.currentMatchup.item1_id,
                item2_id: window.currentMatchup.item2_id,
                item1_name: window.currentMatchup.item1_name,
                item2_name: window.currentMatchup.item2_name,
                winner: result
            };
            
            const response = await fetch(`/api/collections/${currentCollectionId}/matchup`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    item1_id: window.currentMatchup.item1_id,
                    item2_id: window.currentMatchup.item2_id,
                    winner: result
                })
            });
            
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Error submitting matchup: ${errorText}`);
            }
            
            // On success, update rankings and load next matchup
            await loadRankings(); // Update rankings
            await loadNextMatchup(); // Load next matchup (this will clear selectedVote and update button states)
        }

        async function revealScores() {
            if (!window.currentMatchup) {
                alert('No matchup loaded');
                return;
            }
            
            try {
                // Use pre-fetched scores if available, otherwise fetch them
                let item1 = window.currentMatchup.item1_score_data;
                let item2 = window.currentMatchup.item2_score_data;
                
                if (!item1 || !item2) {
                    // Fallback: fetch if not pre-fetched
                    const response = await fetch(`/api/collections/${currentCollectionId}`);
                    const collection = await response.json();
                    
                    item1 = collection.items.find(i => i.id === window.currentMatchup.item1_id);
                    item2 = collection.items.find(i => i.id === window.currentMatchup.item2_id);
                    
                    if (!item1 || !item2) {
                        alert('Could not find item scores');
                        return;
                    }
                }
                
                // Format scores
                let score1Display = `${item1.points > 0 ? '+' : ''}${item1.points}`;
                let score2Display = `${item2.points > 0 ? '+' : ''}${item2.points}`;
                
                if (item1.sub_scores && item1.sub_scores.length > 1) {
                    const formattedScores = item1.sub_scores.map(score => {
                        return score > 0 ? `+${score}` : `${score}`;
                    });
                    score1Display = formattedScores.join(' / ');
                }
                
                if (item2.sub_scores && item2.sub_scores.length > 1) {
                    const formattedScores = item2.sub_scores.map(score => {
                        return score > 0 ? `+${score}` : `${score}`;
                    });
                    score2Display = formattedScores.join(' / ');
                }
                
                // Display scores in the containers underneath item names
                const score1Container = document.getElementById('item1-score-container');
                const score2Container = document.getElementById('item2-score-container');
                
                if (score1Container) {
                    score1Container.innerHTML = `<div style="font-weight: bold; color: #333;">${escapeHtml(score1Display)} pts</div>`;
                }
                
                if (score2Container) {
                    score2Container.innerHTML = `<div style="font-weight: bold; color: #333;">${escapeHtml(score2Display)} pts</div>`;
                }
            } catch (error) {
                console.error('Error revealing scores:', error);
                alert('Error revealing scores');
            }
        }

        function showScorePopup(item1Name, item1Score, item2Name, item2Score) {
            // Remove existing popup if any
            const existingPopup = document.getElementById('score-reveal-popup');
            if (existingPopup) {
                existingPopup.remove();
            }
            
            // Create popup
            const popup = document.createElement('div');
            popup.id = 'score-reveal-popup';
            popup.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 2000; display: flex; align-items: center; justify-content: center;';
            
            popup.innerHTML = `
                <div class="card" style="max-width: 500px; width: 90%; position: relative;">
                    <button onclick="closeScorePopup()" style="position: absolute; top: 10px; right: 10px; background: none; border: none; font-size: 1.5em; cursor: pointer; color: #666; padding: 0; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center;">√ó</button>
                    <h3 class="section-title" style="margin-top: 0;">Current Scores</h3>
                    <div style="display: flex; flex-direction: column; gap: 20px; margin-top: 20px;">
                        <div style="padding: 15px; background: #f8f9fa; border-radius: 6px; border-left: 4px solid #667eea;">
                            <div style="font-weight: bold; margin-bottom: 5px; color: #667eea;">${escapeHtml(item1Name)}</div>
                            <div style="font-size: 1.3em; font-weight: bold; color: #333;">${escapeHtml(item1Score)} pts</div>
                        </div>
                        <div style="padding: 15px; background: #f8f9fa; border-radius: 6px; border-left: 4px solid #667eea;">
                            <div style="font-weight: bold; margin-bottom: 5px; color: #667eea;">${escapeHtml(item2Name)}</div>
                            <div style="font-size: 1.3em; font-weight: bold; color: #333;">${escapeHtml(item2Score)} pts</div>
                        </div>
                    </div>
                    <div style="margin-top: 20px; text-align: center;">
                        <button onclick="closeScorePopup()" style="padding: 10px 30px;">OK</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(popup);
            
            // Close on outside click
            popup.addEventListener('click', (e) => {
                if (e.target === popup) {
                    closeScorePopup();
                }
            });
        }

        function closeScorePopup() {
            const popup = document.getElementById('score-reveal-popup');
            if (popup) {
                popup.remove();
            }
        }

        /**
         * Check if an item matches a given score path.
         * A score path is an array like [5, 2, 1] representing main score, sub-score, sub-sub-score, etc.
         */
        function itemMatchesScorePath(item, scorePath) {
            if (!scorePath || scorePath.length === 0) {
                return true; // Empty path matches all items
            }
            
            // Check main score (first element)
            if (item.points !== scorePath[0]) {
                return false;
            }
            
            // If there are sub-scores, check them
            if (scorePath.length > 1) {
                if (!item.sub_scores || item.sub_scores.length < scorePath.length) {
                    return false; // Item doesn't have enough sub-score levels
                }
                
                // Check each level of sub-scores
                for (let i = 1; i < scorePath.length; i++) {
                    if (item.sub_scores[i] !== scorePath[i]) {
                        return false;
                    }
                }
            }
            
            return true;
        }

        /**
         * Update only the rankings list without reloading the histogram.
         * This is used when histogram bars are clicked to filter rankings.
         */
        async function updateRankingsList() {
            if (isLoadingRankings) return; // Prevent concurrent loads
            isLoadingRankings = true;
            try {
                const response = await fetch(`/api/collections/${currentCollectionId}`);
                const collection = await response.json();
                
                const listEl = document.getElementById('rankings-list');
                listEl.innerHTML = '';
                
                // Filter items based on selected score paths
                let filteredItems = collection.items;
                if (selectedScorePaths.size > 0) {
                    // Convert Set of JSON strings back to arrays
                    const scorePaths = Array.from(selectedScorePaths).map(pathStr => JSON.parse(pathStr));
                    filteredItems = collection.items.filter(item => {
                        // Item matches if it matches ANY selected score path
                        return scorePaths.some(scorePath => itemMatchesScorePath(item, scorePath));
                    });
                }
                
                const totalItems = collection.items.length;
                const filteredItemsCount = filteredItems.length;
                const totalComparisons = collection.comparisons_count;
                const maxComparisons = (totalItems * (totalItems - 1)) / 2;
                
                // Update stats
                const statsEl = document.getElementById('stats');
                statsEl.classList.remove('hidden');
                statsEl.innerHTML = `
                    <div class="stat-card">
                        <div class="value">${filteredItemsCount}${filteredItemsCount !== totalItems ? ` / ${totalItems}` : ''}</div>
                        <div class="label">${filteredItemsCount !== totalItems ? 'Filtered' : 'Total'} Items</div>
                    </div>
                    <div class="stat-card">
                        <div class="value">${totalComparisons}</div>
                        <div class="label">Comparisons Made</div>
                    </div>
                    <div class="stat-card">
                        <div class="value">${maxComparisons}</div>
                        <div class="label">Max Comparisons</div>
                    </div>
                    <div class="stat-card">
                        <div class="value">${maxComparisons > 0 ? Math.round((totalComparisons / maxComparisons) * 100) : 0}%</div>
                        <div class="label">Progress</div>
                    </div>
                `;
                
                // Render rankings list (without reloading histogram)
                await renderRankingsList(filteredItems, collection.search_prefix || '');
            } catch (error) {
                console.error('Error updating rankings:', error);
            } finally {
                isLoadingRankings = false;
            }
        }

        /**
         * Render the rankings list items.
         * Separated from loadRankings to allow updating list without reloading histogram.
         */
        async function renderRankingsList(filteredItems, searchPrefix) {
            const listEl = document.getElementById('rankings-list');
            listEl.innerHTML = '';
            
            filteredItems.forEach((item, index) => {
                const li = document.createElement('li');
                const pointsClass = item.points > 0 ? 'positive' : item.points < 0 ? 'negative' : '';
                const editingId = `item-${item.id}`;
                const searchUrl = getYouTubeSearchUrl(searchPrefix, item.name);
                
                // Format score display with sub-scores if available
                let scoreDisplay = `${item.points > 0 ? '+' : ''}${item.points}`;
                if (item.sub_scores && item.sub_scores.length > 1) {
                    // Format as X / Y / Z / ...
                    const formattedScores = item.sub_scores.map(score => {
                        return score > 0 ? `+${score}` : `${score}`;
                    });
                    scoreDisplay = formattedScores.join(' / ');
                }
                scoreDisplay += ' pts';
                
                li.innerHTML = `
                    <div style="flex: 1; display: flex; flex-direction: column;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span class="rank-number">#${index + 1}</span>
                            <span class="item-name" id="item-name-${item.id}">${escapeHtml(item.name)}</span>
                            <span class="item-points ${pointsClass}">${scoreDisplay}</span>
                        </div>
                        <div id="item-edit-${item.id}" class="hidden">
                            <div class="edit-form">
                                <input type="text" id="item-name-input-${item.id}" value="${escapeHtml(item.name)}" placeholder="Item name">
                                <input type="text" id="item-media-input-${item.id}" value="${item.media_link || ''}" placeholder="YouTube link (optional)">
                                <button onclick="saveItemEdit(${item.id})">Save</button>
                                <button class="secondary" onclick="cancelItemEdit(${item.id})">Cancel</button>
                            </div>
                        </div>
                        <div id="item-display-${item.id}">
                            ${item.media_link ? (() => {
                                const normalizedUrl = normalizeYouTubeUrl(item.media_link);
                                const displayText = item.media_link;
                                return `<div class="media-link-display">üìé <a href="${escapeHtml(normalizedUrl)}" target="_blank">${escapeHtml(displayText)}</a></div>`;
                            })() : ''}
                            <div class="item-actions">
                                <a href="${escapeHtml(searchUrl)}" target="_blank" style="padding: 6px 12px; font-size: 0.85em; background: #dc3545; color: white; text-decoration: none; border-radius: 4px; display: inline-block;">üîç Search YouTube</a>
                                <button onclick="autoFillYouTube(${item.id}, event)" style="padding: 6px 12px; font-size: 0.85em; background: #28a745; color: white;">ü§ñ Auto YT</button>
                                <button onclick="editItem(${item.id})" style="padding: 6px 12px; font-size: 0.85em;">‚úèÔ∏è Edit</button>
                                <button onclick="viewItemVotes(${item.id})" style="padding: 6px 12px; font-size: 0.85em;">üìä View Votes</button>
                            </div>
                        </div>
                    </div>
                `;
                listEl.appendChild(li);
            });
        }

        async function loadRankings() {
            if (isLoadingRankings) return; // Prevent concurrent loads
            isLoadingRankings = true;
            try {
                const response = await fetch(`/api/collections/${currentCollectionId}`);
                const collection = await response.json();
                
                // Filter items based on selected score paths
                let filteredItems = collection.items;
                if (selectedScorePaths.size > 0) {
                    // Convert Set of JSON strings back to arrays
                    const scorePaths = Array.from(selectedScorePaths).map(pathStr => JSON.parse(pathStr));
                    filteredItems = collection.items.filter(item => {
                        // Item matches if it matches ANY selected score path
                        return scorePaths.some(scorePath => itemMatchesScorePath(item, scorePath));
                    });
                }
                
                const totalItems = collection.items.length;
                const filteredItemsCount = filteredItems.length;
                const totalComparisons = collection.comparisons_count;
                const maxComparisons = (totalItems * (totalItems - 1)) / 2;
                
                // Update stats
                const statsEl = document.getElementById('stats');
                statsEl.classList.remove('hidden');
                statsEl.innerHTML = `
                    <div class="stat-card">
                        <div class="value">${filteredItemsCount}${filteredItemsCount !== totalItems ? ` / ${totalItems}` : ''}</div>
                        <div class="label">${filteredItemsCount !== totalItems ? 'Filtered' : 'Total'} Items</div>
                    </div>
                    <div class="stat-card">
                        <div class="value">${totalComparisons}</div>
                        <div class="label">Comparisons Made</div>
                    </div>
                    <div class="stat-card">
                        <div class="value">${maxComparisons}</div>
                        <div class="label">Max Comparisons</div>
                    </div>
                    <div class="stat-card">
                        <div class="value">${maxComparisons > 0 ? Math.round((totalComparisons / maxComparisons) * 100) : 0}%</div>
                        <div class="label">Progress</div>
                    </div>
                `;
                
                // Load and render histogram (full reload)
                await loadHistogram();
                
                // Render rankings list
                await renderRankingsList(filteredItems, collection.search_prefix || '');
            } catch (error) {
                console.error('Error loading rankings:', error);
                alert('Error loading rankings');
            } finally {
                isLoadingRankings = false;
            }
        }

        async function deleteCollection(id) {
            if (!confirm('Are you sure you want to delete this collection?')) {
                return;
            }
            
            try {
                const response = await fetch(`/api/collections/${id}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    if (currentCollectionId === id) {
                        showCollections();
                    } else {
                        loadCollections();
                    }
                } else {
                    alert('Error deleting collection');
                }
            } catch (error) {
                console.error('Error deleting collection:', error);
                alert('Error deleting collection');
            }
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function normalizeYouTubeUrl(url) {
            if (!url) return '';
            
            const trimmed = url.trim();
            
            // If it's already a full URL, return as-is
            if (trimmed.startsWith('http://') || trimmed.startsWith('https://')) {
                return trimmed;
            }
            
            // Check if it looks like a YouTube video ID (11 characters, alphanumeric + _ and -)
            const videoIdPattern = /^([a-zA-Z0-9_-]{11})$/;
            if (videoIdPattern.test(trimmed)) {
                // Convert video ID to full YouTube URL
                return `https://www.youtube.com/watch?v=${trimmed}`;
            }
            
            // If it's not a video ID and doesn't have a protocol, assume it's not a valid URL
            // Return as-is (user might want to fix it)
            return trimmed;
        }

        function getYouTubeEmbed(url) {
            if (!url) return '';
            
            // Extract YouTube video ID from various URL formats
            let videoId = null;
            
            // Standard formats: https://www.youtube.com/watch?v=VIDEO_ID
            // or https://youtu.be/VIDEO_ID
            // or https://www.youtube.com/embed/VIDEO_ID
            const patterns = [
                /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
                /^([a-zA-Z0-9_-]{11})$/ // Just the video ID
            ];
            
            for (const pattern of patterns) {
                const match = url.match(pattern);
                if (match) {
                    videoId = match[1];
                    break;
                }
            }
            
            if (!videoId) {
                // If not a YouTube URL, normalize it first to ensure it's a valid link
                const normalizedUrl = normalizeYouTubeUrl(url);
                return `<div class="media-link-display" style="margin-top: 10px;">
                    <a href="${escapeHtml(normalizedUrl)}" target="_blank">üîó Open Media Link</a>
                </div>`;
            }
            
            return `<div class="video-container">
                <iframe src="https://www.youtube.com/embed/${videoId}" 
                    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                    allowfullscreen>
                </iframe>
            </div>`;
        }

        function editItem(itemId) {
            document.getElementById(`item-display-${itemId}`).classList.add('hidden');
            document.getElementById(`item-edit-${itemId}`).classList.remove('hidden');
        }

        function cancelItemEdit(itemId) {
            document.getElementById(`item-display-${itemId}`).classList.remove('hidden');
            document.getElementById(`item-edit-${itemId}`).classList.add('hidden');
        }

        async function saveItemEdit(itemId) {
            const nameInput = document.getElementById(`item-name-input-${itemId}`);
            const mediaInput = document.getElementById(`item-media-input-${itemId}`);
            
            const name = nameInput.value.trim();
            let mediaLink = mediaInput.value.trim();
            
            // Normalize YouTube URLs before saving
            if (mediaLink) {
                mediaLink = normalizeYouTubeUrl(mediaLink);
            }
            
            if (!name) {
                alert('Item name cannot be empty');
                return;
            }
            
            try {
                const response = await fetch(`/api/items/${itemId}`, {
                    method: 'PUT',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        name: name,
                        media_link: mediaLink || null
                    })
                });
                
                if (response.ok) {
                    // Reload rankings to reflect changes
                    await loadRankings();
                } else {
                    alert('Error updating item');
                }
            } catch (error) {
                console.error('Error updating item:', error);
                alert('Error updating item');
            }
        }

        async function addItemsToCollection() {
            const itemsInput = document.getElementById('new-items-input');
            const itemsText = itemsInput.value.trim();
            
            if (!itemsText) {
                alert('Please enter at least one item');
                return;
            }
            
            try {
                const response = await fetch(`/api/collections/${currentCollectionId}/items`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({items: itemsText})
                });
                
                if (response.ok) {
                    const data = await response.json();
                    itemsInput.value = '';
                    alert(`Successfully added ${data.added} item(s)`);
                    await loadRankings(); // Refresh rankings
                } else {
                    alert('Error adding items');
                }
            } catch (error) {
                console.error('Error adding items:', error);
                alert('Error adding items');
            }
        }

        function toggleExportMenu() {
            const menu = document.getElementById('export-menu');
            if (menu.classList.contains('hidden')) {
                menu.classList.remove('hidden');
                menu.style.display = 'block';
                // Close menu when clicking outside
                setTimeout(() => {
                    document.addEventListener('click', closeExportMenuOnOutsideClick, true);
                }, 0);
            } else {
                closeExportMenu();
            }
        }

        function closeExportMenu() {
            const menu = document.getElementById('export-menu');
            menu.classList.add('hidden');
            menu.style.display = 'none';
            document.removeEventListener('click', closeExportMenuOnOutsideClick, true);
        }

        function closeExportMenuOnOutsideClick(event) {
            const menu = document.getElementById('export-menu');
            if (!menu.contains(event.target) && event.target.onclick !== toggleExportMenu) {
                closeExportMenu();
            }
        }

        async function getCollectionExportData() {
            if (!currentCollectionId) return null;
            
            const response = await fetch(`/api/collections/${currentCollectionId}/export`);
            if (!response.ok) {
                throw new Error('Error exporting collection');
            }
            
            const data = await response.json();
            return JSON.stringify(data, null, 2);
        }

        async function exportCollectionToFile(event) {
            if (event) event.stopPropagation();
            closeExportMenu();
            
            try {
                const jsonStr = await getCollectionExportData();
                if (!jsonStr) return;
                
                // Create download link
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ranqr-${currentCollection.name.replace(/[^a-z0-9]/gi, '_')}-${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Error exporting collection:', error);
                alert('Error exporting collection');
            }
        }

        async function exportCollectionToClipboard(event) {
            if (event) event.stopPropagation();
            closeExportMenu();
            
            const button = event ? event.target : null;
            const originalText = button ? button.textContent : '';
            
            try {
                const jsonStr = await getCollectionExportData();
                if (!jsonStr) return;
                
                // Copy to clipboard
                await navigator.clipboard.writeText(jsonStr);
                
                // Show success feedback
                if (button) {
                    button.textContent = '‚úì Copied!';
                    button.style.background = '#28a745';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.background = '';
                    }, 2000);
                } else {
                    alert('Copied to clipboard!');
                }
            } catch (error) {
                console.error('Error copying to clipboard:', error);
                // Fallback for older browsers
                try {
                    const jsonStr = await getCollectionExportData();
                    if (jsonStr) {
                        const textArea = document.createElement('textarea');
                        textArea.value = jsonStr;
                        textArea.style.position = 'fixed';
                        textArea.style.opacity = '0';
                        document.body.appendChild(textArea);
                        textArea.select();
                        try {
                            document.execCommand('copy');
                            alert('Copied to clipboard!');
                        } catch (err) {
                            alert('Failed to copy. Please copy manually.');
                        }
                        document.body.removeChild(textArea);
                    }
                } catch (err) {
                    alert('Error copying to clipboard');
                }
            }
        }

        function showCreateDialog() {
            document.getElementById('create-collection-form').classList.remove('hidden');
            document.getElementById('collection-name').focus();
        }

        function hideCreateDialog() {
            document.getElementById('create-collection-form').classList.add('hidden');
            document.getElementById('collection-name').value = '';
            document.getElementById('search-prefix-input').value = '';
            document.getElementById('items-input').value = '';
        }

        function showImportDialog() {
            document.getElementById('import-dialog').classList.remove('hidden');
            document.getElementById('import-dialog').style.display = 'flex';
            document.getElementById('import-json-input').focus();
        }

        function hideImportDialog() {
            document.getElementById('import-dialog').classList.add('hidden');
            document.getElementById('import-dialog').style.display = 'none';
            document.getElementById('import-json-input').value = '';
        }

        async function importCollection() {
            const jsonInput = document.getElementById('import-json-input').value.trim();
            
            if (!jsonInput) {
                alert('Please paste JSON data');
                return;
            }
            
            try {
                const data = JSON.parse(jsonInput);
                
                const response = await fetch('/api/collections/import', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(data)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    hideImportDialog();
                    alert(`Successfully imported collection! ${result.items_imported} items, ${result.comparisons_imported} comparisons.`);
                    // Refresh collections list and open the new collection
                    loadCollections();
                    // Small delay to ensure collection is saved
                    setTimeout(() => {
                        openCollection(result.collection_id);
                    }, 500);
                } else {
                    const error = await response.json();
                    alert(`Error importing: ${error.error || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Error importing collection:', error);
                alert('Error importing collection. Please check the JSON format.');
            }
        }

        let currentVotesItemId = null;

        async function viewItemVotes(itemId) {
            currentVotesItemId = itemId;
            
            try {
                const response = await fetch(`/api/items/${itemId}/votes`);
                if (!response.ok) {
                    alert('Error loading voting history');
                    return;
                }
                
                const data = await response.json();
                
                // Update dialog header
                document.getElementById('votes-item-name').textContent = `Voting History: ${data.item.name}`;
                document.getElementById('votes-wins-count').textContent = data.wins.length;
                document.getElementById('votes-losses-count').textContent = data.losses.length;
                document.getElementById('votes-ties-count').textContent = data.ties.length;
                document.getElementById('votes-points').textContent = data.item.points;
                
                // Render wins
                const winsList = document.getElementById('votes-wins-list');
                winsList.innerHTML = '';
                if (data.wins.length === 0) {
                    winsList.innerHTML = '<p style="color: #666; font-style: italic;">No wins yet</p>';
                } else {
                    data.wins.forEach(win => {
                        const card = document.createElement('div');
                        card.className = 'vote-item-card win';
                        card.innerHTML = `
                            <span class="vote-item-name">${escapeHtml(win.other_item_name)}</span>
                            <span class="vote-item-action" onclick="changeVote(${itemId}, ${win.other_item_id}, event)">Change Vote</span>
                        `;
                        winsList.appendChild(card);
                    });
                }
                
                // Render losses
                const lossesList = document.getElementById('votes-losses-list');
                lossesList.innerHTML = '';
                if (data.losses.length === 0) {
                    lossesList.innerHTML = '<p style="color: #666; font-style: italic;">No losses yet</p>';
                } else {
                    data.losses.forEach(loss => {
                        const card = document.createElement('div');
                        card.className = 'vote-item-card loss';
                        card.innerHTML = `
                            <span class="vote-item-name">${escapeHtml(loss.other_item_name)}</span>
                            <span class="vote-item-action" onclick="changeVote(${itemId}, ${loss.other_item_id}, event)">Change Vote</span>
                        `;
                        lossesList.appendChild(card);
                    });
                }
                
                // Render ties
                const tiesList = document.getElementById('votes-ties-list');
                tiesList.innerHTML = '';
                if (data.ties.length === 0) {
                    tiesList.innerHTML = '<p style="color: #666; font-style: italic;">No ties yet</p>';
                } else {
                    data.ties.forEach(tie => {
                        const card = document.createElement('div');
                        card.className = 'vote-item-card tie';
                        card.innerHTML = `
                            <span class="vote-item-name">${escapeHtml(tie.other_item_name)}</span>
                            <span class="vote-item-action" onclick="changeVote(${itemId}, ${tie.other_item_id}, event)">Change Vote</span>
                        `;
                        tiesList.appendChild(card);
                    });
                }
                
                // Show dialog
                document.getElementById('votes-dialog').classList.remove('hidden');
                document.getElementById('votes-dialog').style.display = 'flex';
            } catch (error) {
                console.error('Error loading voting history:', error);
                alert('Error loading voting history');
            }
        }

        function hideVotesDialog() {
            document.getElementById('votes-dialog').classList.add('hidden');
            document.getElementById('votes-dialog').style.display = 'none';
            currentVotesItemId = null;
        }

        async function changeVote(itemXId, itemYId, event) {
            if (event) event.stopPropagation();
            
            // Get item names for better prompt
            const collectionResponse = await fetch(`/api/collections/${currentCollectionId}`);
            const collection = await collectionResponse.json();
            const itemX = collection.items.find(i => i.id === itemXId);
            const itemY = collection.items.find(i => i.id === itemYId);
            
            const itemXName = itemX ? itemX.name : 'Item X';
            const itemYName = itemY ? itemY.name : 'Item Y';
            
            // Show a simple prompt to change the vote
            const newResult = prompt(`Change vote between:\n"${itemXName}" vs "${itemYName}"\n\n1 = "${itemXName}" wins\n2 = "${itemYName}" wins\n3 = Tie\n\nEnter 1, 2, or 3:`);
            
            if (!newResult) return;
            
            let winner;
            if (newResult === '1') {
                winner = 'item1'; // X wins
            } else if (newResult === '2') {
                winner = 'item2'; // Y wins
            } else if (newResult === '3') {
                winner = 'tie';
            } else {
                alert('Invalid choice. Please enter 1, 2, or 3.');
                return;
            }
            
            // Determine which is item1 and item2 for the API
            const item1_id = Math.min(itemXId, itemYId);
            const item2_id = Math.max(itemXId, itemYId);
            
            // Adjust winner if IDs were swapped
            let adjustedWinner = winner;
            if (itemXId > itemYId) {
                if (winner === 'item1') {
                    adjustedWinner = 'item2';
                } else if (winner === 'item2') {
                    adjustedWinner = 'item1';
                }
            }
            
            try {
                const response = await fetch(`/api/collections/${currentCollectionId}/matchup`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        item1_id: item1_id,
                        item2_id: item2_id,
                        winner: adjustedWinner
                    })
                });
                
                if (response.ok) {
                    // Refresh voting history and rankings
                    await viewItemVotes(itemXId);
                    await loadRankings();
                } else {
                    alert('Error updating vote');
                }
            } catch (error) {
                console.error('Error updating vote:', error);
                alert('Error updating vote');
            }
        }

        async function changeLastVote() {
            if (!window.lastVote) {
                alert('No previous vote to change');
                return;
            }
            
            const itemXId = window.lastVote.item1_id;
            const itemYId = window.lastVote.item2_id;
            const itemXName = window.lastVote.item1_name;
            const itemYName = window.lastVote.item2_name;
            
            // Show prompt with current result pre-selected
            let currentChoice = '3'; // Default to tie
            if (window.lastVote.winner === 'item1') {
                currentChoice = '1';
            } else if (window.lastVote.winner === 'item2') {
                currentChoice = '2';
            }
            
            const promptText = `Change last vote:\n"${itemXName}" vs "${itemYName}"\n\nCurrent: ${window.lastVote.winner === 'item1' ? `"${itemXName}" won` : window.lastVote.winner === 'item2' ? `"${itemYName}" won` : 'Tie'}\n\n1 = "${itemXName}" wins\n2 = "${itemYName}" wins\n3 = Tie\n\nEnter 1, 2, or 3 (or Cancel to keep current):`;
            const newResult = prompt(promptText, currentChoice);
            
            if (!newResult) return; // User cancelled
            
            let winner;
            if (newResult === '1') {
                winner = 'item1';
            } else if (newResult === '2') {
                winner = 'item2';
            } else if (newResult === '3') {
                winner = 'tie';
            } else {
                alert('Invalid choice. Please enter 1, 2, or 3.');
                return;
            }
            
            // Check if vote actually changed
            if (winner === window.lastVote.winner) {
                alert('Vote unchanged');
                return;
            }
            
            // Determine which is item1 and item2 for the API
            const item1_id = Math.min(itemXId, itemYId);
            const item2_id = Math.max(itemXId, itemYId);
            
            // Adjust winner if IDs were swapped
            let adjustedWinner = winner;
            if (itemXId > itemYId) {
                if (winner === 'item1') {
                    adjustedWinner = 'item2';
                } else if (winner === 'item2') {
                    adjustedWinner = 'item1';
                }
            }
            
            try {
                const response = await fetch(`/api/collections/${currentCollectionId}/matchup`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        item1_id: item1_id,
                        item2_id: item2_id,
                        winner: adjustedWinner
                    })
                });
                
                if (response.ok) {
                    // Update last vote info
                    window.lastVote.winner = winner;
                    
                    // Reload rankings and current matchup
                    await loadRankings();
                    await loadNextMatchup();
                } else {
                    alert('Error updating vote');
                }
            } catch (error) {
                console.error('Error updating vote:', error);
                alert('Error updating vote');
            }
        }

        async function resetItemVotes() {
            if (!currentVotesItemId) return;
            
            if (!confirm('Are you sure you want to reset all votes for this item? This will remove all comparisons involving this item and cannot be undone.')) {
                return;
            }
            
            try {
                const response = await fetch(`/api/items/${currentVotesItemId}/votes`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    const result = await response.json();
                    alert(`Successfully reset ${result.comparisons_reset} comparison(s).`);
                    hideVotesDialog();
                    await loadRankings(); // Refresh rankings
                } else {
                    alert('Error resetting votes');
                }
            } catch (error) {
                console.error('Error resetting votes:', error);
                alert('Error resetting votes');
            }
        }

        function setupMatchupEditSection(item1, item2) {
            const editSection = document.getElementById('matchup-edit-section');
            const editItems = document.getElementById('matchup-edit-items');
            
            editItems.innerHTML = `
                <div id="edit-item-${item1.id}" class="hidden">
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #667eea;">
                        <div style="font-weight: bold; margin-bottom: 10px;">Edit: ${escapeHtml(item1.name)}</div>
                        <div class="form-group" style="margin-bottom: 10px;">
                            <label>Name:</label>
                            <input type="text" id="matchup-item-name-${item1.id}" value="${escapeHtml(item1.name)}" style="width: 100%; padding: 8px;">
                        </div>
                        <div class="form-group" style="margin-bottom: 10px;">
                            <label>Media Link (YouTube URL or video ID):</label>
                            <input type="text" id="matchup-item-media-${item1.id}" value="${item1.media_link || ''}" placeholder="Paste YouTube link here" style="width: 100%; padding: 8px;">
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button onclick="saveMatchupItemEdit(${item1.id})">Save</button>
                            <button class="secondary" onclick="cancelMatchupItemEdit(${item1.id})">Cancel</button>
                        </div>
                    </div>
                </div>
                <div id="edit-item-${item2.id}" class="hidden">
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #667eea;">
                        <div style="font-weight: bold; margin-bottom: 10px;">Edit: ${escapeHtml(item2.name)}</div>
                        <div class="form-group" style="margin-bottom: 10px;">
                            <label>Name:</label>
                            <input type="text" id="matchup-item-name-${item2.id}" value="${escapeHtml(item2.name)}" style="width: 100%; padding: 8px;">
                        </div>
                        <div class="form-group" style="margin-bottom: 10px;">
                            <label>Media Link (YouTube URL or video ID):</label>
                            <input type="text" id="matchup-item-media-${item2.id}" value="${item2.media_link || ''}" placeholder="Paste YouTube link here" style="width: 100%; padding: 8px;">
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button onclick="saveMatchupItemEdit(${item2.id})">Save</button>
                            <button class="secondary" onclick="cancelMatchupItemEdit(${item2.id})">Cancel</button>
                        </div>
                    </div>
                </div>
            `;
        }

        function toggleEditItem(itemId, event) {
            if (event) event.stopPropagation();
            
            const editDiv = document.getElementById(`edit-item-${itemId}`);
            const editSection = document.getElementById('matchup-edit-section');
            
            if (editDiv.classList.contains('hidden')) {
                // Show this item's edit form, hide others
                document.querySelectorAll('[id^="edit-item-"]').forEach(el => {
                    el.classList.add('hidden');
                });
                editDiv.classList.remove('hidden');
                editSection.classList.remove('hidden');
                
                // Focus on media link input
                const mediaInput = document.getElementById(`matchup-item-media-${itemId}`);
                if (mediaInput) {
                    setTimeout(() => mediaInput.focus(), 100);
                }
            } else {
                editDiv.classList.add('hidden');
                // Hide section if no edits are visible
                const visibleEdits = document.querySelectorAll('[id^="edit-item-"]:not(.hidden)');
                if (visibleEdits.length === 0) {
                    editSection.classList.add('hidden');
                }
            }
        }

        function cancelMatchupItemEdit(itemId) {
            const editDiv = document.getElementById(`edit-item-${itemId}`);
            const editSection = document.getElementById('matchup-edit-section');
            editDiv.classList.add('hidden');
            
            // Hide section if no edits are visible
            const visibleEdits = document.querySelectorAll('[id^="edit-item-"]:not(.hidden)');
            if (visibleEdits.length === 0) {
                editSection.classList.add('hidden');
            }
        }

        async function saveMatchupItemEdit(itemId) {
            const nameInput = document.getElementById(`matchup-item-name-${itemId}`);
            const mediaInput = document.getElementById(`matchup-item-media-${itemId}`);
            
            const name = nameInput.value.trim();
            let mediaLink = mediaInput.value.trim();
            
            // Normalize YouTube URLs
            if (mediaLink) {
                mediaLink = normalizeYouTubeUrl(mediaLink);
            }
            
            if (!name) {
                alert('Item name cannot be empty');
                return;
            }
            
            try {
                const response = await fetch(`/api/items/${itemId}`, {
                    method: 'PUT',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        name: name,
                        media_link: mediaLink || null
                    })
                });
                
                if (response.ok) {
                    // Close edit form
                    cancelMatchupItemEdit(itemId);
                    
                    // Reload the SAME matchup to show updated videos/names
                    // Preserve the current matchup instead of getting a new random one
                    if (window.currentMatchup && window.currentMatchup.item1_id && window.currentMatchup.item2_id) {
                        await loadNextMatchup(window.currentMatchup.item1_id, window.currentMatchup.item2_id);
                    } else {
                        // Fallback to new matchup if current matchup not available
                        await loadNextMatchup();
                    }
                } else {
                    alert('Error updating item');
                }
            } catch (error) {
                console.error('Error updating item:', error);
                alert('Error updating item');
            }
        }

        function editCollectionSearchPrefix() {
            const currentPrefix = currentCollection ? (currentCollection.search_prefix || '') : '';
            const newPrefix = prompt('Enter YouTube search prefix (e.g., artist name):', currentPrefix);
            
            if (newPrefix === null) return; // User cancelled
            
            const searchPrefix = newPrefix.trim() || null;
            
            fetch(`/api/collections/${currentCollectionId}`, {
                method: 'PUT',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({search_prefix: searchPrefix})
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Update current collection data
                    currentCollection.search_prefix = searchPrefix;
                    // Update display
                    const prefixDisplay = document.getElementById('search-prefix-value');
                    if (prefixDisplay) {
                        prefixDisplay.textContent = searchPrefix || 'None';
                    }
                    // Reload rankings to update search links
                    loadRankings();
                    // Reload matchup if it's visible to update search links
                    if (!document.getElementById('matchup-section').classList.contains('hidden')) {
                        loadNextMatchup();
                    }
                } else {
                    alert('Error updating search prefix');
                }
            })
            .catch(error => {
                console.error('Error updating search prefix:', error);
                alert('Error updating search prefix');
            });
        }

        async function autoFillYouTube(itemId, event) {
            if (event) event.stopPropagation();
            
            // Show loading state
            let buttonElement = null;
            const originalText = 'ü§ñ Auto YT';
            if (event && event.target) {
                buttonElement = event.target;
                buttonElement.disabled = true;
                buttonElement.textContent = '‚è≥ Loading...';
            }
            
            try {
                const response = await fetch(`/api/items/${itemId}/auto-youtube`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'}
                });
                
                const data = await response.json();
                
                if (response.ok && data.success) {
                    // Update was successful
                    // If we're in a matchup view, reload the same matchup to show the video
                    if (window.currentMatchup && window.currentMatchup.item1_id && window.currentMatchup.item2_id) {
                        await loadNextMatchup(window.currentMatchup.item1_id, window.currentMatchup.item2_id);
                    } else {
                        // Otherwise just reload rankings
                        await loadRankings();
                    }
                    
                    // Show success message briefly
                    if (buttonElement) {
                        buttonElement.textContent = '‚úì Done!';
                        setTimeout(() => {
                            if (buttonElement) {
                                buttonElement.textContent = originalText;
                                buttonElement.disabled = false;
                            }
                        }, 1500);
                    }
                } else {
                    alert(data.error || 'Could not automatically find YouTube video. Please search manually and add the link.');
                    if (buttonElement) {
                        buttonElement.textContent = originalText;
                        buttonElement.disabled = false;
                    }
                }
            } catch (error) {
                console.error('Error auto-filling YouTube:', error);
                alert('Error auto-filling YouTube video. Please try again or add manually.');
                if (buttonElement) {
                    buttonElement.textContent = originalText;
                    buttonElement.disabled = false;
                }
            }
        }

        // Histogram functions
        
        /**
         * Get all bars in the same histogram as the given bar
         */
        function getBarsInSameHistogram(barElement) {
            const bars = [];
            
            // Find the container/row that contains this bar
            const row = barElement.closest('.histogram-row');
            const container = document.getElementById('histogram-container');
            
            if (row) {
                // Nested histogram - get all bars from this row
                const allBars = row.querySelectorAll('.histogram-bar');
                allBars.forEach(b => bars.push(b));
            } else if (container && container.contains(barElement)) {
                // Top-level histogram - get all bars from main container
                const allBars = container.querySelectorAll('.histogram-bar');
                allBars.forEach(b => bars.push(b));
            }
            
            return bars;
        }
        
        /**
         * Close a histogram row and all its child histograms recursively
         */
        function closeHistogramAndChildren(row) {
            if (!row) return;
            
            // Find all child rows (rows that have this row's path as a prefix)
            const rowId = row.id;
            // Extract the score path from the row ID: "histogram-row-5-2-1" -> [5, 2, 1]
            // Handle negative numbers by using a more robust parsing
            const pathPart = rowId.replace('histogram-row-', '');
            // Split by '-' but be careful with negative numbers
            // We'll use a regex to match numbers (including negative)
            const rowPath = pathPart.match(/-?\d+/g) ? pathPart.match(/-?\d+/g).map(s => parseInt(s)) : [];
            
            // Find all histogram rows
            const allRows = document.querySelectorAll('.histogram-row');
            allRows.forEach(childRow => {
                const childRowId = childRow.id;
                const childPathPart = childRowId.replace('histogram-row-', '');
                const childPath = childPathPart.match(/-?\d+/g) ? childPathPart.match(/-?\d+/g).map(s => parseInt(s)) : [];
                
                // Check if this child row is a descendant of the row being closed
                if (childPath.length > rowPath.length) {
                    // Check if childPath starts with rowPath
                    let isDescendant = true;
                    for (let i = 0; i < rowPath.length; i++) {
                        if (childPath[i] !== rowPath[i]) {
                            isDescendant = false;
                            break;
                        }
                    }
                    
                    if (isDescendant) {
                        // Close this child row and unselect its parent bar
                        childRow.style.display = 'none';
                        
                        // Find and unselect the parent bar
                        const parentPath = childPath.slice(0, -1);
                        const parentScore = childPath[childPath.length - 1];
                        const parentBarId = `histogram-bar-${parentPath.join('-')}-${parentScore}`;
                        const parentBar = document.getElementById(parentBarId);
                        if (parentBar) {
                            parentBar.classList.remove('clicked');
                            // Remove from selectedScorePaths
                            const parentBarScorePathJson = parentBar.getAttribute('data-score-path');
                            if (parentBarScorePathJson) {
                                selectedScorePaths.delete(parentBarScorePathJson);
                            }
                        }
                        
                        // Remove all bars in this child row from selectedScorePaths
                        const childBars = childRow.querySelectorAll('.histogram-bar');
                        childBars.forEach(bar => {
                            const barScorePathJson = bar.getAttribute('data-score-path');
                            if (barScorePathJson) {
                                selectedScorePaths.delete(barScorePathJson);
                            }
                        });
                    }
                }
            });
            
            // Close this row
            row.style.display = 'none';
            
            // Unselect the parent bar that triggered this histogram
            const parentPath = rowPath.slice(0, -1);
            const parentScore = rowPath[rowPath.length - 1];
            const parentBarId = `histogram-bar-${parentPath.join('-')}-${parentScore}`;
            const parentBar = document.getElementById(parentBarId);
            if (parentBar) {
                parentBar.classList.remove('clicked');
                // Remove from selectedScorePaths
                const parentBarScorePathJson = parentBar.getAttribute('data-score-path');
                if (parentBarScorePathJson) {
                    selectedScorePaths.delete(parentBarScorePathJson);
                }
            }
            
            // Remove all bars in this row from selectedScorePaths
            const rowBars = row.querySelectorAll('.histogram-bar');
            rowBars.forEach(bar => {
                const barScorePathJson = bar.getAttribute('data-score-path');
                if (barScorePathJson) {
                    selectedScorePaths.delete(barScorePathJson);
                }
            });
        }
        
        async function loadHistogram() {
            if (!currentCollectionId) return;
            
            const container = document.getElementById('histogram-container');
            container.innerHTML = '<div class="loading">Loading histogram...</div>';
            
            try {
                const response = await fetch(`/api/collections/${currentCollectionId}/score-distribution`);
                if (!response.ok) {
                    container.innerHTML = '<div class="loading">Error loading histogram</div>';
                    return;
                }
                
                const data = await response.json();
                renderHistogram(data.distribution, container, []);
            } catch (error) {
                console.error('Error loading histogram:', error);
                container.innerHTML = '<div class="loading">Error loading histogram</div>';
            }
        }

        function renderHistogram(distribution, container, scorePath, level = 0) {
            if (!distribution || distribution.length === 0) {
                if (level === 0 && container) {
                    container.innerHTML = '<div class="loading">No data available</div>';
                }
                return;
            }
            
            // Find max count for scaling
            const maxCount = Math.max(...distribution.map(d => d.count));
            const maxHeight = level === 0 ? 200 : 150; // pixels
            
            // Build histogram HTML
            let histogramHTML = '<div class="histogram">';
            
            distribution.forEach(item => {
                const height = maxCount > 0 ? (item.count / maxCount) * maxHeight : 0;
                const scoreLabel = item.score > 0 ? `+${item.score}` : `${item.score}`;
                const hasSubScores = item.sub_score_distribution && item.sub_score_distribution.length > 0;
                const barId = `histogram-bar-${scorePath.join('-')}-${item.score}`;
                
                histogramHTML += `
                    <div class="histogram-bar" 
                         id="${barId}"
                         data-score="${item.score}"
                         data-score-path='${JSON.stringify([...scorePath, item.score])}'
                         data-level="${level}"
                         data-has-sub-scores="${hasSubScores}"
                         style="height: ${height}px;"
                         title="Score ${scoreLabel}: ${item.count} item(s)${hasSubScores ? ' (click to drill down)' : ''}">
                        <span class="histogram-bar-value">${item.count}</span>
                        <span class="histogram-bar-label">${scoreLabel}</span>
                    </div>
                `;
            });
            
            histogramHTML += '</div>';
            
            if (level === 0) {
                if (container) {
                    container.innerHTML = histogramHTML;
                }
            } else {
                // For nested histograms, create a row container
                const rowId = `histogram-row-${scorePath.join('-')}`;
                let existingRow = document.getElementById(rowId);
                if (!existingRow) {
                    const row = document.createElement('div');
                    row.id = rowId;
                    row.className = `histogram-row level-${level}`;
                    
                    // Build path label
                    const pathLabels = scorePath.map((s, i) => {
                        const label = s > 0 ? `+${s}` : `${s}`;
                        return i === 0 ? `Score ${label}` : `Sub-score ${label}`;
                    });
                    const headerText = pathLabels.join(' ‚Üí ');
                    
                    row.innerHTML = `
                        <div class="histogram-row-header">${headerText}</div>
                        ${histogramHTML}
                    `;
                    
                    // Insert after the parent histogram's container
                    // Find the parent bar that was clicked to trigger this drill-down
                    const parentScorePath = scorePath.slice(0, -1);
                    const clickedScore = scorePath[scorePath.length - 1];
                    const parentBarId = `histogram-bar-${parentScorePath.join('-')}-${clickedScore}`;
                    const parentBar = document.getElementById(parentBarId);
                    
                    const mainContainer = document.getElementById('histogram-container');
                    const histogramSection = mainContainer.closest('#histogram-section');
                    
                    if (parentBar) {
                        // Find the row containing the parent bar
                        const parentRow = parentBar.closest('.histogram-row');
                        if (parentRow) {
                            // Insert after the parent row
                            parentRow.parentNode.insertBefore(row, parentRow.nextSibling);
                        } else {
                            // Parent bar is in main container, insert after main container
                            if (histogramSection) {
                                histogramSection.insertBefore(row, mainContainer.nextSibling);
                            } else {
                                mainContainer.parentNode.insertBefore(row, mainContainer.nextSibling);
                            }
                        }
                    } else {
                        // Fallback: append to histogram section or main container's parent
                        if (histogramSection) {
                            histogramSection.appendChild(row);
                        } else {
                            mainContainer.parentNode.appendChild(row);
                        }
                    }
                    existingRow = row;
                } else {
                    // Update existing row
                    existingRow.querySelector('.histogram').outerHTML = histogramHTML;
                }
            }
            
            // Add click handlers
            let bars;
            if (level === 0) {
                bars = container.querySelectorAll('.histogram-bar');
            } else {
                const row = document.getElementById(`histogram-row-${scorePath.join('-')}`);
                bars = row ? row.querySelectorAll('.histogram-bar') : [];
            }
            
            bars.forEach(bar => {
                // Remove existing click handlers by cloning
                const newBar = bar.cloneNode(true);
                bar.parentNode.replaceChild(newBar, bar);
                
                newBar.addEventListener('click', async function(e) {
                    e.stopPropagation(); // Prevent event bubbling
                    
                    const score = parseInt(this.getAttribute('data-score'));
                    const scorePathJson = this.getAttribute('data-score-path');
                    const hasSubScores = this.getAttribute('data-has-sub-scores') === 'true';
                    const currentLevel = parseInt(this.getAttribute('data-level')) || 0;
                    
                    const newScorePath = JSON.parse(scorePathJson);
                    const scorePathKey = scorePathJson; // Use JSON string as key for Set
                    
                    // Check if this bar is currently selected BEFORE unselecting others
                    const isCurrentlySelected = this.classList.contains('clicked');
                    
                    // Get all bars in the same histogram (same container/row)
                    const sameHistogramBars = getBarsInSameHistogram(this);
                    
                    // Remove all score paths from bars in the same histogram from selectedScorePaths
                    // and close their child histograms
                    sameHistogramBars.forEach(b => {
                        const barScorePathJson = b.getAttribute('data-score-path');
                        if (barScorePathJson) {
                            // Check if this bar has a child histogram that needs to be closed
                            const barScorePath = JSON.parse(barScorePathJson);
                            const barChildRowId = `histogram-row-${barScorePath.join('-')}`;
                            const barChildRow = document.getElementById(barChildRowId);
                            if (barChildRow) {
                                // Close the child histogram and all its descendants
                                closeHistogramAndChildren(barChildRow);
                            }
                            
                            selectedScorePaths.delete(barScorePathJson);
                        }
                        b.classList.remove('clicked');
                    });
                    
                    // Check if child histogram already exists
                    const childRowId = `histogram-row-${newScorePath.join('-')}`;
                    const existingChildRow = document.getElementById(childRowId);
                    
                    if (isCurrentlySelected) {
                        // Bar was already selected - close the nested histogram
                        if (existingChildRow) {
                            closeHistogramAndChildren(existingChildRow);
                        }
                    } else {
                        // Select this bar for filtering
                        this.classList.add('clicked');
                        selectedScorePaths.add(scorePathKey);
                        
                        // If bar has sub-scores, also handle drill-down
                        if (hasSubScores) {
                            if (existingChildRow) {
                                // Show existing child histogram
                                existingChildRow.style.display = 'block';
                            } else {
                                // Load and render child histogram
                                await loadChildHistogram(newScorePath, currentLevel + 1);
                            }
                        }
                    }
                    
                    // Update rankings list to apply filtering (without reloading histogram)
                    if (!isLoadingRankings) {
                        await updateRankingsList();
                    }
                });
            });
            
            // Restore clicked state for bars that are in selectedScorePaths
            bars.forEach(bar => {
                const barScorePathJson = bar.getAttribute('data-score-path');
                if (barScorePathJson && selectedScorePaths.has(barScorePathJson)) {
                    bar.classList.add('clicked');
                    // If bar has sub-scores, also restore nested histogram visibility
                    const hasSubScores = bar.getAttribute('data-has-sub-scores') === 'true';
                    if (hasSubScores) {
                        const scorePath = JSON.parse(barScorePathJson);
                        const childRowId = `histogram-row-${scorePath.join('-')}`;
                        const childRow = document.getElementById(childRowId);
                        if (childRow) {
                            childRow.style.display = 'block';
                        } else {
                            // Child histogram doesn't exist yet - load it
                            const currentLevel = parseInt(bar.getAttribute('data-level')) || 0;
                            loadChildHistogram(scorePath, currentLevel + 1).catch(err => {
                                console.error('Error restoring child histogram:', err);
                            });
                        }
                    }
                }
            });
        }

        async function loadChildHistogram(scorePath, level) {
            if (!currentCollectionId) return;
            
            try {
                const scorePathJson = JSON.stringify(scorePath);
                const response = await fetch(
                    `/api/collections/${currentCollectionId}/score-distribution/recursive?score_path=${encodeURIComponent(scorePathJson)}`
                );
                
                if (!response.ok) {
                    console.error('Error loading child histogram');
                    return;
                }
                
                const data = await response.json();
                // For nested histograms, pass null as container since renderHistogram will create its own row
                renderHistogram(data.distribution, null, scorePath, level);
            } catch (error) {
                console.error('Error loading child histogram:', error);
            }
        }
    </script>
</body>
</html>

